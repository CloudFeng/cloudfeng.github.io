[{"title":"脚踏实地学习","date":"2018-06-28T16:00:00.000Z","path":"2018/06/29/arts/share/S-learn-by-hard-way/","text":"¶概述 本周阅读了Peter Norving 写的一篇文章《Teach Yourself Programming in Ten Years》1 和 Alan Sorkin 写的一篇文章《The Greatest Developer Fallacy Or The Wisest Words You’ll Ever Hear?》2 。这两篇文章给我的感触比较深，所以本周就分享一下文章大概内容以及本周根据 MDN一步一步做的一个mntfun静态页面。 ¶态度：无捷径可走 主要讲我们学习编程所需要的态度不要企图一蹴而就，也不要好高骛远，没有捷径可走。 刻意练习 The key is deliberative practice: not just doing it again and again, but challenging yourself with a task that is just beyond your current ability, trying it, analyzing your performance while and after doing it, and correcting any mistakes. Then repeat. And repeat again. ** There appear to be no real shortcuts **: even Mozart, who was a musical prodigy at age 4, took 13 more years before he began to produce world-class music. In another genre, the Beatles seemed to burst onto the scene with a string of #1 hits and an appearance on the Ed Sullivan show in 1964. But they had been playing small clubs in Liverpool and Hamburg since 1957, and while they had mass appeal early on, their first great critical success, Sgt. Peppers, was released in 1967. 不要相信：用到的时候再学习，注意平时的积累； 两篇文章都提到要与高手一起合作，沟通； 保持激情 Maybe it is just that people don’t know how to build expertise (there is an element of truth to this), but I have a sneaking suspicion that it’s more about lack of desire rather than lack of knowledge. ¶成为程序员的步骤 我是一个初学者，没有啥资格说如何成为一个程序员，一个好的程序员，直接引用 Pert Noring的经验。如下： Get interested in programming, and do some because it is fun. Program. The best kind of learning is learning by doing. Talk with other programmers; read other programs. If you want, put in four years at a college (or more at a graduate school). Work on projects with other programmers. Learn at least a half dozen programming languages. Remember that there is a “computer” in “computer science”. Get involved in a language standardization effort. Have the good sense to get off the language standardization effort as quickly as possible. ¶分享mntfun介绍网页 本周业余时间跟着MDN开发网站3，学习web开发，主要是跟着入门教程，然后改写成mntfun一个介绍 网站。如下图，比较简陋。 ¶参考资料 1.https://www.skorks.com/2011/02/the-greatest-developer-fallacy-or-the-wisest-words-youll-ever-hear/ ↩2.https://www.skorks.com/2011/02/the-greatest-developer-fallacy-or-the-wisest-words-youll-ever-hear/ ↩3.https://developer.mozilla.org/en-US/docs/Learn/Getting_started_with_the_web ↩","comments":true,"tags":[{"name":"share","slug":"share","permalink":"http://yoursite.com/tags/share/"},{"name":"learning","slug":"learning","permalink":"http://yoursite.com/tags/learning/"}]},{"title":"ARTS之旅","date":"2018-06-22T16:00:00.000Z","path":"2018/06/23/arts/6m3w-summary/","text":"¶本周ARTS总结 ARTS是左耳朵耗子发起的一个活动，具体如下： Algorithm：每周至少做一个leetcode的算法题; Review：阅读并点评至少一篇英文技术文章； Tip/Techni：学习至少一个技术技巧； Share：分享一篇有观点和思考的技术文章； 你需要坚持至少一年！ 在微信群里面看到此活动的时候，晚上还失眠了，回想自己读书以及工作一年，没有什么习惯坚持下来， 都是两天打鱼三天晒网。现在一直都生活在舒适区或着看了比较多材料也没有什么输出，内心忒崩溃， 越想越烦躁，最后失眠了,后面想将ARTS作为自己的一个项目去维护，既然遇到左耳朵耗子哥，有契机， 就好好把握，也想看看自己能走多远，也希望藉此机会好好锻炼自己。想那么多，又不能改变啥，去做就是。 我自己理解的ARTS目的 A:我学习比较浮躁，夯实以前看算法书，锻炼一下自己的思维能力； R:督促自己学习英语，去总结和思考； T:不要放弃技术，相信技术，积累； S:学会分享，与人沟通，而不是一个人独自学习； 总之，积少成多，说了这么多，该谈谈本周开启ARTS之旅，分享的内容如下： leetcode在做了一个简单地算法题目Two Sum，给定一个数组和一个值，找出两个值之和等于给定的值； 分享一下本周看的英文文章，主要是多兴趣以及一周5小时法则； 分享本周遇到一个简单线上bug以及处理流程; 本周学习TDD开发，分享一下阅读测试驱动开发笔记一; ARTS活动内容来源：左耳朵耗子 20180615 发得的微博。","comments":true,"tags":[{"name":"ARTS","slug":"ARTS","permalink":"http://yoursite.com/tags/ARTS/"}]},{"title":"Algorithm:Two Sum","date":"2018-06-22T16:00:00.000Z","path":"2018/06/23/arts/algorithm/A-TwoSum/","text":"¶问题描述 Given an array of integers, return indices of the two numbers such that they add up to a specific target.You may assume that each input would have ** exactly one solution**, and you may not use the same element twice. Example Given nums = [2, 7, 11, 15], target = 9, Because nums[0] + nums[1] = 2 + 7 = 9, return [0, 1]. ¶解题思路与状态 当时看完题目给自己定了一个30分钟的闹钟，可以在这段时间中搞定它。存在疑问： 若数组排序，可以使用两边夹方法解决之；若不是怎么处理。 数组中是否存在重复元素，若有怎么处理。 未找到满足条件的元素，是抛出异常还是给定特殊的标志，比如[-1,-1]。 看完题目之后头脑中形成的解题思路暴力破解法，一下搞完，本地测试通过了，时间复杂度为 O(n^2)。 不是自己想要的结果，接着想能都把元素的值与下标对应起来，然后再去查找，利用空间换时间，以缩短查询 时间。后面出现了使用hashmap做处理的元素值，这种情况在数组中存在重复元素有问题。后面想了很久 仍旧没有想到使用一个hashmap来解决此问题。这个时候已经过去40分钟，心里面开始出现焦急状态， 无奈之下看答案了。两种hashmap的方法的空间复杂度为O(n),时间复杂度为O(n)。下面就将每个 解法的关键点列出来。 ¶暴力破解法 1234567891011121314public int[] twoSum(int[] nums, int target) &#123; if (null == nums || nums.length &lt;= 1) &#123; return new int[] &#123;-1, -1&#125;; &#125; int len = nums.length; for (int i = 0; i &lt; len; i++) &#123; for (int j = i + 1; j &lt; len; j++) &#123; if (nums[j] == target - nums[i]) &#123; return new int[] &#123; i, j &#125;; &#125; &#125; &#125; return new int[] &#123;-1, -1&#125;;&#125; ¶双哈希法 1234567891011121314151617public int[] twoSum(int[] nums, int target) &#123; if (null == nums || nums.length &lt;= 1) &#123; return new int[] &#123;-1, -1&#125;; &#125; Map&lt;Integer, Integer&gt; map = new HashMap&lt;Integer,Integer&gt;(); int len = nums.length; for (int i = 0; i &lt; len; i++) &#123; map.put(nums[i], i); &#125; for (int i = 0; i &lt; len; i++) &#123; int right = target - nums[i]; if (map.containsKey(right) &amp;&amp; map.get(right) != i) &#123; return new int[] &#123; i, map.get(right) &#125;; &#125; &#125; return new int[] &#123;-1, -1&#125;;&#125; ¶单哈希法 1234567891011121314public int[] twoSum(int[] nums, int target) &#123; if (null == nums || nums.length &lt;= 1) &#123; return new int[] &#123;-1, -1&#125;; &#125; Map&lt;Integer, Integer&gt; map = new HashMap&lt;Integer,Integer&gt;(); for (int i = 0; i &lt; len; i++) &#123; int right = target - nums[i]; if (map.containsKey(right)) &#123; return new int[] &#123; i, map.get(right) &#125;; &#125; map.put(right, i); &#125; return new int[] &#123;-1, -1&#125;;&#125; ¶总结 以后做算法题或者解决难题的时候，要懂得放一放，不要非得在一定的时间之内完成，特别是在做算法题。 毕竟在leetcode上做算法题不是为了刷题目，而是为了锻炼自己的思维还有夯实算法知识。","comments":true,"tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://yoursite.com/tags/algorithm/"}]},{"title":"Review:多兴趣成功以及5小时法则","date":"2018-06-22T16:00:00.000Z","path":"2018/06/23/arts/review/R-mutil-interests/","text":"¶概述 本周阅读了多兴趣与成功以及5小时法则，将其中要点以及自己的感悟分享给大家。 ¶多兴趣与成功 《People Who Have “Too Many Interests” Are More Likely To Be Successful According To Research》一文表明的观点是在现在或者未来，通才更容易成功。读完之后有如下感触： 多视角看问题，更容易解决复杂问题； 保持好奇心，心态要开放不要鄙视或者轻视任何新事物； 学习的东西必须用起来； 读完此文还有吴军老师的《见识》中关于跨界的介绍。加上自己这几年读书和近一年的工作经历，这也想学习， 那也想学习，但是啥没有深入进去。都是学了点皮毛。就如同猴子摘棒子一般。培养的兴趣要为某个核心领域 服务，能够将兴趣结合在一起才行。所以给我自己的告诫： 不要过多兴趣，除非那些天赋和精力超级旺盛的人； 读书或者做事情一定要持续投入； ¶5小时法则 5小时法则的来源是富兰克林，他每日都抽取至少1小时投入学习，每周5个小时。作者也列举了很多例子： Warren Buffett spends five or six hours per day reading five newspapers and 500 pages of corperate reports. Bill Gates reads 50 books per year. Mark Cuban read more than 3 hours every day. Mark Zuckerberg reads at least one book two weeks. … 作者建议如下： Reading：每日不断阅读； Refection： 反思所学以及自己的行为； Experimentation: 解决遇到的问题，利用你学到知识。 Don’t be lazy. Don’t make excuses. Just get it done. ¶参考资料 Why Constant Learners All Embrace the 5-Hour Rule Bill Gates, Warren Buffett And Oprah All Use The 5-Hour Rule 5-Hour Rule: If you’re not spending 5 hours per week learning, you’re being irresponsible People Who Have “Too Many Interests” Are More Likely To Be Successful According To Research 吴军 《见识》关于跨界的介绍","comments":true,"tags":[{"name":"review","slug":"review","permalink":"http://yoursite.com/tags/review/"},{"name":"5小时法则","slug":"5小时法则","permalink":"http://yoursite.com/tags/5小时法则/"},{"name":"兴趣","slug":"兴趣","permalink":"http://yoursite.com/tags/兴趣/"}]},{"title":"测试驱动开发笔记之入门","date":"2018-06-22T16:00:00.000Z","path":"2018/06/23/arts/share/S-TDD-note/","text":"¶无意间接触TDD 以前写个小函数之后，一直用main函数来做单元测试。看看是否有其他的方法，不用老这么整。 后面听到过xUnit啥，然后在网上也看一部分资料，Junit简要入门,junit-tutorials等。 弄完之后觉得好奇，想知道Junit是谁先提出的，无意间就找到 Kent Beck 的一本关于测试驱动开发的书： 《Test-Driven Development By Example》。 ¶TDD 小结 后面每天抽点时间把第一章的知识看完，主要围绕资金实例一步一步的介绍测试驱动开发，作者忒细心， 深怕介绍的过快而没有讲清楚。今日把相关的要点列出来，最近慢慢在开始练习开发模式写代码。示例代码 可以参考TDD。 ¶测试驱动开发的目标 每一种开发方法都是为了解决某个问题而来的，而测试驱动开发的目的就是为让人写出整洁可用的代码。 ¶测试驱动开发的态度 测试优先 只有自动测试失败时，才重写代码 不可运行/可运行/重构 不断构建测试列表 ¶测试驱动开发的过程 加入一个小的测试； 运行所有测试，运行测试； 适当修改; 运行测试且成功; 重构，消除重复设计，优化设计结构。 ¶三个测试驱动开发小技巧 让测试利落运行的三种方法 伪方法:返回一个常量并逐渐用变量代替常量，直至伪实现代码成为真实地代码 三角法：在例子达到2个或更多时才对代码实施一般化 显明实现：实现真实的代码 把消除代码与测试间的重复设计作为驱动设计的一种手段 控制测试间隙的能力，不知如何下手，就放慢，在状况好时就开快一些 ¶参考资料 http://www.vogella.com/tutorials/JUnit/article.html http://www.mkyong.com/tutorials/junit-tutorials/","comments":true,"tags":[{"name":"TDD","slug":"TDD","permalink":"http://yoursite.com/tags/TDD/"},{"name":"share","slug":"share","permalink":"http://yoursite.com/tags/share/"}]},{"title":"一个bug引发另个bug","date":"2018-06-22T16:00:00.000Z","path":"2018/06/23/arts/tip/T-onlineproblem/","text":"¶一个bug背景 在周三快下班的时候，临时接到需求，需要修改协议书模板，后端只需要修改脚本即可。由于周四是版本 上线的最后一天，所以建议不要修改，原因如下： 每次发版当天的环境会很差，各个关联方环境极其不稳定； 本身有很多需求都没全部覆盖测试； 改完之后都需要走回归测试，测试同事有时间么； 但是组长觉得小小需求，测试负责人也说支持。最后妥协，修改了，当天就搞定了。周四开始回归测试，测试 同事测试出一个bug了，为说明此bug产生的缘由，说明一些简称： 1.客户级别L：（0：低；1：高）; 2.数据源： 客户OCR扫描完证件信息（A） 本地数据库（B） 客户预留信息（C） 关系方的信息（D） 3.渠道：A 和 B 需求做一个比对，判断是否同一个人，此需求是小灰同事负责开发（同事之间需要和谐相处说，随意取名小 灰。 ），在此将简单写成伪代码，如下： 12345678910111213141516171819202122232425262728293031 res = false // 块1 if A then if A == B then res = true else res = false END END// 块2 if L == 0 then // 块2.1 if D 存在 then if A == D then res = true else res = false END else res = true END // 块2.2 else if A == C then res = true else res = false END END return res 周四测试同事发现低级别的客户，OCR扫的与本地库不同，居然也认为是本人，所以将bug给小灰和我。当 时我看着日志，把数据对比的数据拿出来，写单元测试，发现确实如此。然后就叫小灰过来，给他讲了一下， 发现的问题，A渠道来的在块1比较是不同的人，客户又是低级的而D数据不存，覆盖了之前校验的值，将其 变为是本人了。后面他说：“不是很明白，回桌上自己想想”。最后他说改完了，移交测试了。由于我负责其 他的需求开发，负责查日志，忙着就忘记去看小灰怎么改的。后面就上线了，由于小灰需要支持版本发布， 周五调休。 ¶另一个bug背景 周五一上班，大概10点多，收到很多邮件，一会查这个一会查另外一个。当天看到6笔报不是本人的异常， 赶紧查日志。拉取最新的代码，查完分析代码。小灰修改后的代码，改写伪代码如下： 1234567891011121314151617181920212223242526272829303132res = false // 块1 if A then if A == B then res = true else res = false END END// 块2 if L == 0 then // 块2.1 if D 存在 then if A == D then res = true else res = false END //else // 小灰修改处 // res = true END // 块2.2 else if A == C then res = true else res = false END END return res 分析出来是，B渠道，低级别客户，在数据D不存在的情况下，一直是非本人。所以与测试沟通造相关的数 据，复现生成问题。 ¶bug修复处理 最后跟领导申请紧急版本处理修复，由于是由一个bug引起bug，问了如下三个问题： 修改的代码是否有review 测试同事是否有案例review 是否负责人报备 我的回答都是否定的，当时发现第一个bug的时候，我跟测试负责人打了招呼，但是没有跟组长说，后面也没 有review小灰修改的代码。处理此事我司步骤如下： 发邮件申请紧急版本给部门长； 开发直属领导与部门长说明bug问题； 修复bug 测试回归 发布版本 生成验证 修改小灰的代码如下： 12345678910111213141516171819202122232425262728293031res = false // 块1 if A then if A == B then res = true else return false // 修1 END END// 块2 if L == 0 then // 块2.1 if D 存在 then if A == D then res = true else return false // 修改2 END else // 修改3 仍旧加上 res = true END // 块2.2 else if A == C then res = true else res = false END END return res 然后与组长一起review代码，影响业务比较大，所以需要快速解决，没有重构代码。好了之后，画好流程 图，给测试同事讲解，再告诉测试同事在测试环境造什么样的数据，让其一个分支一个分支的测试。上线之 后，自己又找人生产验证。 ¶总结 问责的时候，心里面确实不舒服，不是我的错，为啥要我承担。 后面想想，自己也有责任，发现了bug， 没有和小灰一同修复。今天就把此两个bug回顾，总结如下： 复杂的业务逻辑画好流程图，与测试同事一同案例评审； 开发单元测试一定做足； 不要逃避责任。","comments":true,"tags":[{"name":"bug","slug":"bug","permalink":"http://yoursite.com/tags/bug/"},{"name":"线上问题","slug":"线上问题","permalink":"http://yoursite.com/tags/线上问题/"}]},{"title":"mock和RAP入门教程","date":"2017-07-30T16:00:00.000Z","path":"2017/07/31/mock-rap-basic-uasge/","text":"在很早以前公司里面就接入了rap在线管理接口文档平台，通过图形化书写接口文档，给前端同事使用。但是之前也仅仅是用于写接口文档，从来没有研究过它还有其他用途。最近与自己合作的一个前端同事说，你为啥不利用好rap来写接口文档，它会自动生成mock数据，我们就不用将rap默认生成的数据修改后，再本地测试一下。弄完之后再与你们联调。今儿就花了2个小时左右研究一下rap，顺藤摸瓜出来mock。下面简单介绍一下，mock以及如何在rap中使用mock，生成比较好的模拟数据，提高前后端协作效率。 ¶mock.js1 mock.js随机生成数据，让前端开发人员在开发阶段时独立于后端，使用mockjs可以自测代码。 ¶语法规范 数据模板定义规范(DTD:Data Template Definition) 数据占位符规范(DPD: Data Placeholder definition) ¶数据模板定义规范 ¶格式 'name|rule':value (属性名|生成规则:属性值)，其中生成规则是可选的 ¶生成规则 7种生成规则 'name|min-max':value 'name|count':value 'name|min-max.dmin-dmax':value 'name|+step':value 'name|min-max.dcount':value 'name|count.dmin-dmax':value 'name|count.dcount':value 生成规则的含义依赖属性值的类型才能确认，这一点特别重要。也是mock的关键所在。 比如： 'name|min-max':string: 通过重复[min,max]次string生成新字符串。 'name|min-max':number: 生成一个number，返回在[min,max]。 ¶属性值 属性值可含@（占位符） 指定最终的值和类型 属性值类型 String Number Boolean Object Array Function RegExp Path 学过js看着十分简单，只是多了RegExp 和 Path，其他简直一模一样。 ¶数据占位符定义规范DPD ¶占位符 1.占位符只是在属性字符串中占个位置，并不出现在最终的属性值中 2.格式：@占位符或者@占位符(参数[,参数]) 3.占位符 用@标识后面的字符串是占位符 引用的是Mock.Random中的方法 扩展定义占位符：Mock.Random.extend() 引用数据模板中的属性 支持相对路径和绝对路径 4.数据占位符类型 数据占位符一共有如下几种类型： Basic Date Image Color Text Name Web Address Helper Miscellaneous 具体mock语法示例，请参考mock示例2，里面详细的介绍了各个类型使用方法。 ¶rap写接口文档中运用mock3 ¶什么是rap RAP是前后端沟通桥梁的通信接口，是一个图形化的接口文档管理的软件。它可以自动生成mock数据，在开发时候前端同事可以不依赖于后端的数据，而是根据mock规则自动生成的模拟数据进行测试。 ¶怎么在rap中是使用mock 有很多资料，且是图文并茂写博文4,5。总结起来，在rap中运用mock方法如下： 左边变量写 name|rule，此处相当于就是mock中的'name|rule'; 右边备注写 @mock=value。其语法规则mock一样。 1.https://github.com/nuysoft/Mock/wiki ↩2.http://mockjs.com/examples.html ↩3.https://github.com/thx/RAP/wiki/ ↩4.http://www.imooc.com/article/17588 ↩5.http://blog.sina.com.cn/s/blog_c00ccc680102x0ue.html ↩","comments":true,"tags":[{"name":"mock","slug":"mock","permalink":"http://yoursite.com/tags/mock/"},{"name":"RAP","slug":"RAP","permalink":"http://yoursite.com/tags/RAP/"}]},{"title":"python实现http发送POST请求","date":"2017-07-24T16:00:00.000Z","path":"2017/07/25/python-http-post/","text":"现在开发是前后端完全分离的，在公司里面很多接口都和登陆态相关联起来。从而使得我在需求开发的时候依赖于前端同事打包完之后才开始测试自己的需求功能。所以比较耗费时间和精力。但是我们的服务接口是不依赖登陆态的，为了测试自己的服务接口，需要模拟发送HTTP请求，以便后面偷懒。本文就此介绍一下如何解决此问题。 ¶语言选择以及依赖包 为了能够快速解决此问题，首先需要找到合适的工具，俗话说，“工欲善其事，必先利其器。” 在程序设计中首先就是语言的选择，相比于java，对python更为熟悉一点。说句皮外话， 虽然在公司用java开发，但是对java熟悉程度不如python,汗颜啦。回归正题，选好了 语言之后，紧接着就是如何模拟发送HTTP请求。google一番找到一个第三方包urllib3。 如何安装urllib3以及使用文档教程。 ¶实现 现在我们来看看，如何使用urllib3包来模拟发送HTTP的POST请求，请求参数是JSON格式。为了能够使用urllib3模块，需要在使用导入urllib3模块，代码：import urllib3。使用PoolManager 实例来发送请求，它已经为我们封装处理好了连接池以及线程安全问题，我们没有必要再次徒手开发一套。其实，urllib3中最为核心关键的方法是request方法，它指定发送请求的方式、请求地址请求的参数。具体步骤如下： 指定请求方法以及url; 将请求的参数编码，然后作为body的值; 设置请求头部的Content-Type为JSON格式. 下面是一个示例代码： 12345678910111213#-*- coding:utf-8 -*-import urllib3from urllib import urlencodeimport jsondef testEsaInterface(url, param): http = urllib3.PoolManager() try: r = http.request('POST',url, body=json.dumps(param).encode('utf-8'),headers=&#123;'Content-Type': 'application/json'&#125;) if r.status == 200: print r.data except urllib3.exceptions.MaxRetryError as e: print repr(e) 如果想对返回的结果进行处理，先将返回的数据进行解码以及反序列化，可以使用decode函数解码，loads函数反序列化。然后采用类似于下标的访问方式获取相关字段的值。示例代码如下： 123res = json.loads(r.data.decode('utf-8'))if (\"906\" == res['data']['returnCode']): # to do something 下图是我测试人脸识别功能一个测试结果： ¶postman发送post请求 弄完工具之后，本来想再做一个网页版的，后面发现chrome中有一个插件postman, 可以解决我的问题，突然发现重复造轮子咯。下面简单介绍一下，如何用postman发送 post请求，其中请求的参数为JSON格式。步骤如下： 选择发送请求的方式为 POST; 输入访问的URL 在headers标签页输入 Content-type, 对应的值为 application/json; 在body标签页面，选择raw,然后在输入JSON格式的请求参数; 最后点击send按钮即可. 是不是发现很简单，如果你觉得还是不清楚,可以参考此博文。 本文仅仅简单介绍了urllib3模块发送HTTP的POST请求方式，还有很多功能需要大家自己去发掘。 ¶参考 安装urllib3: https://pypi.python.org/pypi/urllib3/ urllib3的使用教程: https://urllib3.readthedocs.io/en/latest/user-guide.html postman以JSON格式发送POST请求: http://www.cnblogs.com/shimh/p/6093229.html","comments":true,"tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"},{"name":"http","slug":"http","permalink":"http://yoursite.com/tags/http/"}]},{"title":"Hello World","date":"2017-07-21T16:00:00.000Z","path":"2017/07/22/hello-world/","text":"大家好： 本文是使用Hexo的第一篇博文，主要是给大家报个到。欢迎来到我的菜园子。","comments":true,"tags":[{"name":"随记","slug":"随记","permalink":"http://yoursite.com/tags/随记/"}]},{"title":"sicp 数据对象之集合操作","date":"2017-07-21T16:00:00.000Z","path":"2017/07/22/sicp-dataobject-set/","text":"本文主要介绍不同的数据抽象，对应用程序在使用公共函数时会造成何种影响。这里主要是使用集合使用三种数据来表示：集合作为未排序的表、集合作为排序的表、集合作为有序二叉树，探讨不同的数据对象形式表示集合时，对使用集合的程序性能的影响。 ¶基本概念 选择函数与构造函数 构造函数：说明一个数据对象是由哪些原始组成的。 选择函数：怎么将数据对象中的组成元素抽取出来。 数据抽象定义 数据定义就是一组选择函数与构造函数，以及为了使它们成为一套合法的表示。因此它们需要满足一组特定的条件。 看着上面两个定义是不是很拗口，不知道在说啥。举个例子来说，如果一个有理数p是由整数 n 和 整数 d 构造而成。也就是 p = n /d。 12345;构造函数 p = n / dp = (make-rat n d);选择函数n = (numer p)d = (denom p) ¶集合操作 在高中的数学我们学习过，集合表示一组无重复的元素聚集而成。在数据结构中，集合表示一组具有相同属性的元素，并且满足数学中的集合属性：无序性。 常见集合的操作，判断某个元素是否属于某个集合、求两个集合的交集、求两个集合的并集。假设集合A={1,2,3}、B={2,3,4}，以及元素m=2,n=5，则： 判断某个元素是否属于某个集合：m 属于A,也属于B，而n不属于A,也不属于B; A 与 B 的交集为：{2, 3}; A 与 B 的并集为：{1, 2, 3, 4} 下面我们来看看使用三种不同的数据表示，会对写集合常见操作造成什么样影响。 ¶集合作为未排序的表 ¶构造函数与选择函数 直接使用list 函数，但是集合中元素是排序的，比如集合A={1, 10, 2, 4, 3}。 ¶判断某个元素是否属于某个集合 1234(define (element-of-set? x set) (cond ((null? set) #f) (else (or (equal? x (car set)) (element-of-set? x (cdr set)))))) ¶求两个集合的交集 12345(define (intersection-set set1 set2) (cond ((or (null? set1) (null? set2)) &apos;()) ((element-of-set? (car set1) set2) (cons (car set1) (intersection-set (cdr set1) set2))) (else (intersection-set (cdr set1) set2)))) ¶求两个集合的并集 123456(define (union-set set1 set2) (cond ((null? set1) set2) ((null? set2) set1) ((element-of-set? (car set1) set2) (union-set (cdr set1) set2)) (else (cons (car set1) (union-set (cdr set1) set2))))) ¶将某个元素加入集合中 1234(define (adjion-set x set) (if (element-of-set? x set) set (cons x set))) ¶集合作为排序的表 ¶构造函数与选择函数 直接使用list 函数，但是集合中元素是排序的，比如集合A={1, 2, 3, 4, 5, 10}。 ¶判断某个元素是否属于某个集合 12345(define (element-of-set? x set) (cond ((null? set) #f) ((equal? x (car set)) #t) ((&lt; x (car set)) #f) (else (element-of-set? x (cdr set))))) ¶求两个集合的交集 12345678(define (intersection-sort-set set1 set2) (if (or (null? set1) (null? set2)) &apos;() (let ((x (car set1)) (y (car set2))) (cond ((= x y) (cons x (ntersection-sort-set (cdr set1) (cdr set2)))) ((&lt; x y) (intersection-sort-set (cdr set1) set2)) (else (intersection-sort-set set1 (cdr set2))))))) ¶将某个元素加入到集合中 12345(define (adjoin-set x set) (cond ((null? set) (cons x set)) ((equal? x (car set)) set) ((&lt; x (car set)) (cons x set)) (else (cons (car set) (adjoin-set x (cdr set)))))) ¶求两个集合的并集 12345678(define (union-sort-set set1 set2) (cond ((null? set1) set2) ((null? set2) set1) (else (let ((x (car set1)) (y (car set2))) (cond ((&lt; x y) (cons x (nion-sort-set (cdr set1) set2))) ((&gt; x y) (cons y (union-sort-set set1 (cdr set2)))) (else (cons x (union-sort-set(cdr set1) (cdr set2))))))))) ¶集合作为有序二叉树 ¶构造函数与选择函数 1234567891011;(dataItem, left-branch, right-branch)(define (entry tree) (car tree))(define (left-branch tree) (cadr tree))(define (right-branch tree) (caddr tree))(define (make-tree entry left-branch right-branch) (list entry left-branch right-branch)) ¶判断某个元素是否属于某个集合 1234567(define (element-of-set? x set) (if (null? set) #f (let ((dataItem (entry set))) (cond ((= dataItem x) #t) ((&gt; dataItem x) (element-of-set x (left-branch set))) (else (element-of-set x (right-branch set))))))) ¶求两个集合的交集 12345(define (intersection-set set1 set2) (let ((list1 (tree-&gt;list set1)) (list2 (tree-&gt;list set2))) (let ((res (intersection-sort-set list1 list2))) (list-tree res)))) ¶求两个集合的并集 1234567891011121314151617181920212223242526272829303132333435; 辅助函数：将树形结构转为列表结构(define (tree-&gt;list tree) (define (copy-to-list tree result-list) (if (null? tree) result-list (copy-to-list (left-branch tree) (cons (entry tree) (copy-to-list (right-branch tree) result-list))))) (copy-to-list tree &apos;()));辅助函数：将列表结构转位树形结构(define (list-tree elements) (car (partial-tree elements (length elements))))(define (partial-tree elts n) (if (= n 0) (cons &apos;() elts) (let ((left-size (quotient (- n 1) 2))) (let ((left-result (partial-tree elts left-size))) (let ((left-tree (car left-result)) (non-left-elts (cdr left-result)) (right-size (- n (+ left-size 1)))) (let ((this-entry (car non-left-elts)) (right-result (partial-tree (cdr non-left-elts) right-size))) (let ((right-tree (car right-result)) (remaining-elts (cdr right-result))) (cons (make-tree this-entry left-tree right-tree) remaining-elts))))))))(define (union-set set1 set2) (let ((list1 (tree-&gt;list set1)) (list2 (tree-&gt;list set2))) (let ((res (union-sort-set list1 list2))) (list-tree res)))) ¶添加元素到集合 123456789(define (adjoin-set x set) (cond ((null? set) (make-tree x &apos;() &apos;())) ((= x (entry set)) set) ((&lt; x (entry set)) (make-tree (entry set) (adjoin-set x (left-branch set)) (right-branch set))) (else (make-tree (entry set) (left-branch set) (adjoin-set x (right-branch set)))))) ¶总结 通过三种不同的数据表示集合，分析了程序在使用集合操作，比如检查是否属于集合、集合的交集、集合并集等操作，在时间复杂度上是存在差异的。如下表格： 表示法 检查元素是否属于集合 添加元素 交集 并集 未排序的表 O(n) O(n) O(n^2) O(n^2) 排序的表 O(n) O(n) O(n) O(n) 有序二叉树 O(log n) O(log n) O(n) O(n) 也就是我们常说: 程序=数据结构+算法","comments":true,"tags":[{"name":"sicp","slug":"sicp","permalink":"http://yoursite.com/tags/sicp/"},{"name":"scheme","slug":"scheme","permalink":"http://yoursite.com/tags/scheme/"}]}]