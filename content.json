[{"title":"Share：5分钟商学院-心理账户","date":"2018-08-04T16:00:00.000Z","path":"2018/08/05/arts/share/S-five-mins-buss-accout/","text":"心理账户概念 我们会把钱分门别类的存在不同的心理账户里面。比如说，生活必要的开支账户，家庭建设和个人发展账户，情感维系账户，享乐休闲账户等等。虽然这些账户都是在一个大账户之下，但其实各个子账户都是独立存在的。 例子 听音乐会前，丢失了200块。当丢失的是价值200块的公交卡时，大多数人会选择继续前往观看；当丢失的是打算用来购买音乐会门票的200块时，大多数人选择不去看了。 总结 我们还有时间账户，空间账户等等账户。有的账户可供他人使用，有些绝对不行。只有替自己利益最大化之后才会心动，花费相关的账户。 注意：5分钟商学院的内容来自得到刘润老师的课程","comments":true,"tags":[{"name":"share","slug":"share","permalink":"http://yoursite.com/tags/share/"},{"name":"消费心理学","slug":"消费心理学","permalink":"http://yoursite.com/tags/消费心理学/"}]},{"title":"ARTS-8月1周","date":"2018-08-04T16:00:00.000Z","path":"2018/08/05/arts/8m1w-summary/","text":"8月1周ARTS总结 分享第7个ARTS的内容： 1.A：189.Rotate Array 2.R：PM的12条经验 3.T:Nginx静态资源服务器无法加载CSS文件 4.S:心理账户","comments":true,"tags":[{"name":"ARTS","slug":"ARTS","permalink":"http://yoursite.com/tags/ARTS/"}]},{"title":"Algorithm:189. Rotate Array","date":"2018-08-04T16:00:00.000Z","path":"2018/08/05/arts/algorithm/A-189-Rotate-Array/","text":"问题 Given an array, rotate the array to the right by k steps, where k is non-negative. Example 1: Input: [1,2,3,4,5,6,7] and k = 3 Output: [5,6,7,1,2,3,4] Explanation: rotate 1 steps to the right: [7,1,2,3,4,5,6] rotate 2 steps to the right: [6,7,1,2,3,4,5] rotate 3 steps to the right: [5,6,7,1,2,3,4] Example 2: Input: [-1,-100,3,99] and k = 2 Output: [3,99,-1,-100] Explanation: rotate 1 steps to the right: [99,-1,-100,3] rotate 2 steps to the right: [3,99,-1,-100] Note: Try to come up as many solutions as you can, there are at least 3 different ways to solve this problem. Could you do it in-place with O(1) extra space? 解题思路 直接根据编程珠玑一书中得思路而来的，双手旋转法，具体如下： 12345678910111213141516171819public void rotate(int[] nums, int k) &#123; if (null == nums || nums.length &lt;= 0 || k &lt;= 0) &#123; return; &#125; k = k % nums.length; reverse(nums, 0, nums.length - 1); reverse(nums, 0, k - 1); reverse(nums, k, nums.length - 1);&#125;private void reverse(int[] nums, int start, int end) &#123; while (start &lt; end) &#123; int tmp = nums[start]; nums[start] = nums[end]; nums[end] = tmp; ++start; --end; &#125;&#125; 分析 时间复杂度为O(n)，空间复杂度为O(1);","comments":true,"tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://yoursite.com/tags/algorithm/"},{"name":"array","slug":"array","permalink":"http://yoursite.com/tags/array/"}]},{"title":"Nginx 不能解析CSS文件","date":"2018-08-04T16:00:00.000Z","path":"2018/08/05/arts/tip/T-nginx-css-not-interpreted/","text":"问题描述 最近学习在补前端知识了，使用Nginx做静态内容服务器1。遇到了一个小问题： Resource interpreted as Stylesheet but transferred with MIME type text/plain: “http://localhost/web-projects/the-html-head/styles/styles.css” \b解决方法 \b若不对于css文件解析进行配置，nginx默认文件都是text/plain类型进行解析2，为此我们需要对此进行 简单配置。将下面这段代码放入到location模块下面，然后重启nginx。记住一定要清理浏览器的缓存。 12include mime.types;default_type application/octet-stream; 参考资料 1.http://nginx.org/en/docs/beginners_guide.html ↩2.https://developer.mozilla.org/en-US/docs/Web/Security/Securing_your_site/Configuring_server_MIME_types ↩","comments":true,"tags":[{"name":"tip","slug":"tip","permalink":"http://yoursite.com/tags/tip/"},{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"}]},{"title":"Review - Observations on Product Management","date":"2018-08-04T16:00:00.000Z","path":"2018/08/05/arts/review/R-Obserations-on-PM/","text":"概述 本周分享的文章来自于Airbnb一位前PM，Dan Hill 关于PM的12条经验。觉得蛮有趣的，分享给大家。 12条PM经验 The job of Product Management is to deliver good products to end users. The sheer number of possible definitions of good, product and user mean there’s no standard look to a Product Manager. But if you don’t deliver, the product is not good, or no-one uses it, you’ve done it wrong. Your product, especially if you manage people directly, is not the product. It’s the process that builds the product. Designers output interfaces/interactions, engineers output code, product managers output process. ‘Process’ includes the frameworks for reasoning about a problem, how the team interacts and communicates, expectations of the product, expectations of the team, timelines, what success and quality look like, how decisions are made. Process is not inherently bad. There’s good process and bad process. Good process is any that allows the team to produce better work faster, with joy and elegance. Bad process is anything else. Be wary of people who hate process. Sometimes they have been burned by bad process, often though they fear process is a) the same as bureaucracy or b) will limit their contributions. If you are a new Product Manager to a team that hasn’t worked with one before, the first order of business is proving to the team that your process increases their contributions and joy, not decreases it. It almost doesn’t matter what the product is. The greatest attribute of a Product Manager is a strongly developed ability for metacognition. First, to be able to introspect oneself and see how your words, actions, choices are affecting an outcome. Second, to introspect a process and understand why it is or is not working. Most Product Managers (and everyone probably) spend too little time thinking about how to solve a problem. They jump straight into solving it. Problems come in different shapes, and not all need the same process. The process that shipped the last product is unlikely to be the one that you need for the next. It is easier to macrobullshit than to microbullshit. It is impossible to bullshit good engineers, designers, data scientists, researchers. If the team isn’t calling you out on something fairly regularly, you’re doing it wrong. Where there is skill to move mountains, there is no need for the faith that moves mountains. Faith cannot last — eventually someone has to build something. Incremental development and vision are not orthogonal; they both require the other. All product must start with a vision — a point of view — but then be built critically step by step. It’s ok to learn something new as you go. Being data-driven is not vision. People who cling to being data-driven rarely create anything new or interesting. I also personally find it hard to explain why to them.","comments":true,"tags":[{"name":"review","slug":"review","permalink":"http://yoursite.com/tags/review/"},{"name":"PM","slug":"PM","permalink":"http://yoursite.com/tags/PM/"}]},{"title":"ARTS-7月4周","date":"2018-07-28T16:00:00.000Z","path":"2018/07/29/arts/7m4w-summary/","text":"7月4周ARTS总结 说出的诚诺，需要好好执行，做到。正如刘润老师所说：经营自己。补上六周的ARTS，分享第六个ARTS的内容： 1.A：Algorithm:88.Merge Sorted Array 2.R：日记法则：TLC 3.T:Oracle插入数据报日期数据无效 4.S:本周开始分享刘润的5分钟商学院的内容，经营自己","comments":true,"tags":[{"name":"ARTS","slug":"ARTS","permalink":"http://yoursite.com/tags/ARTS/"}]},{"title":"Algorithm:88.Merge Sorted Array","date":"2018-07-28T16:00:00.000Z","path":"2018/07/29/arts/algorithm/A-258-add-digits/","text":"问题 Given a non-negative integer num, repeatedly add all its digits until the result has only one digit1. Note: The number of elements initialized in nums1 and nums2 are m and n respectively. You may assume that nums1 has enough space (size that is greater or equal to m + n) to hold additional elements from nums2. Example: Input: 38 Output: 2 Explanation: The process is like: 3 + 8 = 11, 1 + 1 = 2. Since 2 has only one digit, return it. Follow up: Could you do it without any loop/recursion in O(1) runtime? Level: Easy 看完题目，之后列举了几个。分别是\b小于9的，\b是9的倍数，不是9的倍数。进行归纳如下: n &lt; 9 直接返回n； n mod 9 = 0 直接返回9, 比如n=18 n mod 9 != 0 直接返回 n mod 9 \b后面看到讨论中，说是 digit root problem2。 根据上述的分析，\b可以直接写出解法，具体如下： 12345678910public int addDigits(int num) &#123; if (num &lt; 10) &#123; return num; &#125; int result = num % 9; if (result != 0) &#123; return result; &#125; return 9;&#125; 分析 时间复杂度为O(1)； 相关资料 1.https://leetcode.com/problems/add-digits/description/ ↩2.https://en.wikipedia.org/wiki/Digital_root ↩","comments":true,"tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://yoursite.com/tags/algorithm/"},{"name":"math","slug":"math","permalink":"http://yoursite.com/tags/math/"}]},{"title":"Oracle插入数据报错","date":"2018-07-28T16:00:00.000Z","path":"2018/07/29/arts/tip/T-oracle-date-error/","text":"背景 最近接手一个老系统，DB使用的是Oracle，很多流程都是用了存储过程和函数。现在不是很熟悉，虽然以前在大学的时候学习Oracle，后面再也没有碰过。现在感慨，知识学了没有用，但一旦需要用到的时候，会发现至少了解一点，不至于那么被动。所以多学习一点技术或者其他生活知识，都是十分必要的，说不定哪天就用上了。 问题描述 在看书的时候，敲入书中的代码，一条简单插入语句，如下： 1INSERT INTO EMP VALUES (7521, 'WARD', 'SALESMAN', 7698,TO_DATE('22-FEB-1981', 'DD-MON-YYYY'), 1250, 500, 30); 提示：ORA-01843: 无效的月份 \b解决方法 看了一下Oracle中关于 TO_DATE函数的文档1 The default date format is determined implicitly by the NLS_TERRITORY initialization parameter or can be set explicitly by the NLS_DATE_FORMAT parameter. 在Datetime格式2中也进行了说明： The default datetime format template is specified either explicitly with the initialization parameter NLS_DATE_FORMAT or implicitly with the initialization parameter NLS_TERRITORY. You can change the default datetime formats for your session with the ALTER SESSION statement. 方法一： 1INSERT INTO EMP VALUES (7521, 'WARD', 'SALESMAN', 7698,TO_DATE('22-FEB-1981', 'DD-MON-YYYY'，'NLS_DATE_LANGUAGE = American'), 1250, 500, 30); 但是需要修改\b每条语句，比较麻烦，\b方法二可以批量搞定。 方法二： 修改当前\b会话的所\b使用的语言，\b具体如下，然后再执行所有的插入语句。 1alter session set nls_date_language='american' 参考资料 1.https://docs.oracle.com/cd/B19306_01/server.102/b14200/functions183.htm ↩2.https://docs.oracle.com/cd/B28359_01/olap.111/b28126/dml_commands_1029.htm#OLADM780 ↩","comments":true,"tags":[{"name":"tip","slug":"tip","permalink":"http://yoursite.com/tags/tip/"},{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"}]},{"title":"Share：刘润-5分钟商学院","date":"2018-07-28T16:00:00.000Z","path":"2018/07/29/arts/share/S-five-mins-buss-start/","text":"背景 在得到上买了刘润的《5分钟商学院》，一直没有怎么看。借助 ARTS 每周分享一下，所读的笔记。 5分钟商学院开篇 开篇的内容主要讲解事人人都要开始经营自己，要对自己负责，时间长度是一生。相关的摘句如下： 你必须像经营公司一样经营自己：构建自己的协作关系、塑造自己的产品和服务、呵护自己的名声、把注意力投放到产出更高的地方。 你“自己”这家公司是无限责任。你需要用自己一生的时间和信用来为它担保。 总结：关注自己的成长，好好经营自己。","comments":true,"tags":[{"name":"share","slug":"share","permalink":"http://yoursite.com/tags/share/"},{"name":"5分钟商学院","slug":"5分钟商学院","permalink":"http://yoursite.com/tags/5分钟商学院/"}]},{"title":"Review - A Better, Easier Way to Journal","date":"2018-07-28T16:00:00.000Z","path":"2018/07/29/arts/review/R-Better-easier-way-to-journal/","text":"概述 作者提出了TLC法则来记录每天的生活记录，其中TLC： Thank：具体到事件，不要泛泛而谈。目的就是为了让自己生活充满希望和感恩之心 Learn：不仅学习书本上知识，还要从每个人身边去学习，去发现； Connect：连接以前学习的知识；连接所接触的人。 TLC 法则 具体的TLC法则描述如下： T：Thank What are you thankful about today? Be specific. So talk about some event that happened to you today that you are grateful about. There’s no escape from the things to be thankful for in your life each day. Make the effort to seek them out, think about them, and express a brief thanks. It will make your daily experience that much richer. 【】 L：Learn What did you learn today? You learn something every day, especially if you interact with other people. you can learn something from everybody you meet each day, and if you don’t think so, you’re not trying. C：Connect What things did you connect? In other words, what concepts did you make an analogy between or otherwise find an intellectual string tying one to the other? Learning is all about connecting things in your mind. Take new information, and tie it in to well-worn knowledge. Find similarities and patterns. With whom did you connect? What conversations did you have, what were they about? What was the takeaway from each? What is that person excited about? What can you talk with them about in the future? What could you work on with them?","comments":true,"tags":[{"name":"rule","slug":"rule","permalink":"http://yoursite.com/tags/rule/"},{"name":"review","slug":"review","permalink":"http://yoursite.com/tags/review/"}]},{"title":"Algorithm:88.Merge Sorted Array","date":"2018-07-21T16:00:00.000Z","path":"2018/07/22/arts/algorithm/A-88-merge-sorted-array/","text":"问题 Description:Given two sorted integer arrays nums1 and nums2, merge nums2 into nums1 as one sorted array. Note: The number of elements initialized in nums1 and nums2 are m and n respectively. You may assume that nums1 has enough space (size that is greater or equal to m + n) to hold additional elements from nums2. Example: Input: nums1 = [1,2,3,0,0,0], m = 3 nums2 = [2,5,6], n = 3 Output: [1,2,2,3,5,6] Level: Easy 解题思路 初看题目很简单，而且一看就是归并排序。\b\b所以开始想着就是顺着归并排序的思路来做，也就是从头开始 遍历；会发现\b需要移动\b数组nums1，导致时间复杂度超过 O(n+m)，不满足归并排序。后面想想，\b居然形成了思维定 势。\b为了满足O(n+m),可以从后面开始遍历，\b只是我们学习的归并排序\b都是从\b头开始，而不是从尾部开始。一旦由从 尾部开始遍历的x想法，问题就解决了。具体见下面的详细代码。 \b详细代码如下： 123456789101112131415public void merge(int[] nums1, int m, int[] nums2, int n) &#123; int i = m-1; int j = n-1; int total = m + n - 1; while (i &gt;= 0 &amp;&amp; j &gt;= 0) &#123; if (nums1[i] &gt;= nums2[j]) &#123; nums1[total--] = nums1[i--]; &#125; else &#123; nums1[total--] = nums2[j--]; &#125; &#125; while (j &gt;= 0) &#123; nums1[total--] = nums2[j--]; &#125;&#125; 分析 时间复杂度为O(n+m),其中n为排序数组的长度；","comments":true,"tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://yoursite.com/tags/algorithm/"},{"name":"array","slug":"array","permalink":"http://yoursite.com/tags/array/"}]},{"title":"Share：python中list操作","date":"2018-07-21T16:00:00.000Z","path":"2018/07/22/arts/share/S-python-list-note/","text":"创建数值列表 使用 range函数, 得到的元素属于：[start, stop) 12for value in range(1, 10, 2): print(value) 使用list函数，构建一个列表 12for elem in list(range(1,10,3)): print(elem) 使用append函数 12345squares = []for value in range(1, 5): squares.append(value ** 2)print(squares) 使用切片构建一个新的列表 123456789my_foods = ['pizza', 'falafel', 'carrot cake']friend_foods = my_foods[:]friend_foods.append('ice cream')print(\"My favorite foods are:\")print(my_foods)print(\"\\nMy friend's favorite foods are:\")print(friend_foods) 列表操作 列表排序操作 改变原来list的排序法: sort属性 正序排 123cars = ['bmw', 'audi', 'toyota', 'subra']cars.sort()print(cars) 逆序排 123cars = ['bmw', 'audi', 'toyota', 'subra']cars.sort(reverse=True)print(cars) 不改变原来list的排序法：sorted 正序排 12cars = ['bmw', 'audi', 'toyota', 'subra']print(sorted(cars)) 逆序排 12cars = ['bmw', 'audi', 'toyota', 'subra']print(sorted(car,reverse=True)) 倒着打印列表 1234cars = ['bmw','audi','toyota','subaru']print(cars)cars.reverse()print(cars) 列表长度 获取列表的长度: len(cars) 列表索引是从0开始的，在不为空的情况下可以使用 -1表示访问最后一个元素 列表遍历 遍历列表，可以使用类似java的foreach语法 12345magicians = ['alice', 'david', 'carolina']for magician in magicians: print(magician.title() + \", that was great trick!\") print(\"I can't wait to see your next trick, \" + magician.title() + \".\\n\")print(\"Thank you everyone,that was a great magic show!\") 简单统计 对数字列表元素惊醒简单地统计 min max sum 123digits = [1, 2, 4, 0, 10, 8, 7, 9]print(str(digits) + \"'s min:\" + str(min(digits))+ \" max:\" + str(max(digits)) + \" sum:\" + str(sum(digits))) 切片操作 语法：var_list[start:end] 构建的列表元素属于 var_list[start],...,var_list[end-1] 说明： var_list[:end]：从头开始到end-1 var_list[start:]:从start开始到len(var_list)-1 var_list[:]:整个var_list 12345players = ['charles', 'matina', 'michael', 'florence', 'eli']print(players[0:3])print(players[:3])print(players[:])print(players[2:]) 应用：分页展示 元组 元组：不可变得列表；不能修改元组中的元素，但可以改变元组变量 使用园括号定义 使用下标或者foreach遍历元组 123456789dimensions = (200, 50)print(dimensions[0])print(str(dimensions[1]) + \"\\n\")for dimension in dimensions: print(dimension)dimensions = (400, 100)print(dimensions)","comments":true,"tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"},{"name":"share","slug":"share","permalink":"http://yoursite.com/tags/share/"}]},{"title":"Share:Redis中的分布式锁","date":"2018-07-21T16:00:00.000Z","path":"2018/07/22/arts/review/R-Distributed-locks-with-redis/","text":"概述 在多核处理器中，互斥性访问共享资源的环境下，分布式锁是一项十分有用的手段（技术）]。有很多库和博客都有描述基于Redis如何实现一个分布式锁管理器（DLM：Distributed Lock Manager），但是每个库都使用不同的方案，相比复杂方案，简单方案有较低保障。 本文试图提供一个经典的方法实现基于Redis的分布式锁。我们提出一个算法，称之为 Redlock，它实现一个DLM。我们相信它比普通的单个实例方法更为安全。我们希望，社区分析它并且提供反馈，同时希望基于Redislock实现或者更为复杂或者其他可选的方案。 实现 在描述Redlock算法之前，列举目前基于Redis设计的分布式锁，具体如下： Redlock-rb (Ruby 实现)。 有一个 Redlock-rb的fork，它新增gem便于发布或者更多 Redlock-py (Python 实现)。 Aioredlock (Asyncio Python 实现)。 Redlock-php (PHP 实现)。 PHPRedisMutex (further PHP 实现) cheprasov/php-redis-lock (PHP 库) Redsync.go (Go 实现)。 Redisson (Java 实现)。 Redis::DistLock (Perl 实现)。 Redlock-cpp (C++ 实现)。 Redlock-cs (C#/.NET 实现)。 RedLock.net (C#/.NET 实现)， 包括异步和支持锁的扩展。 ScarletLock (C# .NET 实现 with configurable datastore) node-redlock (NodeJS 实现)，支持锁的扩展。 安全性和活跃性保证 从我们自己的视角来看，构建我们的设计模型具有三个特性，最低限度地保证高效使用分布式锁。 安全性：互斥性，在任何时刻，仅有一个客户端能否获得锁。 活跃性A：无死锁。不管客户端锁定资源宕或者被分割，最终就可能获得一个锁， 活跃性B:容错性。只要有大多数Redis节点正常工作，客户端就可以获得和释放锁。 为何基于故障转移1实现不够 让我们分析一下目前基于Redis分布式锁库的工作，以便了解我们所做的改进。 使用Redis锁住资源最为简单的方法是在一个实例中创建一个key。所创建的key通常带有一个过期时间，使用了Redis过期的特性，因此它最终会释放锁（安全性和活跃性保证的第二点）。若客户端需要释放资源，只需要删除此key即可。 粗看起来，此机制很好，但是存在一个问题：在我们的体系架构中是一个单点故障。Redis主节点宕了会发生什么？ 当然，我们可以加入一个从节点！并且在主节点不可用时使用从节点。不幸的是，此方案不可行。这么做会导致我们不能实现互斥安全性，是因为Redis主从复制是异步的。 使用上述的模型存在一个很明显的竞态条件，如下： 客户 A 在主节点获取一个锁； 主节点在客户 A 锁住资源的key没能及时写入到从节点情况下宕了； 从节点被选举为主节点； 客户 B 获得客户A锁住的资源的锁。安全性被破坏！ 在特定的场景下，比如在失败的场景下，多个客户端能在同一时刻获得同一个锁，此模型是很好的。如果上述场景符合你的需求，你可以使用基于主从复制解决方案。否则，我们建议实现本文中描述的方案。 单实例正确实现方式 在我们尝试解决上述单实例实现方案缺陷之前，如何在此场景下，如何确保它是正确的。当竞态条件可以接收的时候，此方案是一个可行的方案。另外，在单实例中锁机制是我们在本文中描述分布式算法的基础。为了获得锁，可以使用下面的命令：SET resource_name my_random_value NX PX 30000 此命令会在当key不存在的时候（NX 选项），就会创建一个key，带有一个30000毫秒过期时间（PX 选项）。与key关联的值为“my_random_value”。此值在所有客户端和所有请求锁中，必须是唯一的。使用随机值是为了安全释放锁，使用脚本告诉Redis：只有在key存在并且对应的value值是我们期待的时候才删除它。下面实现此方案的Lua脚本： 12345if redis.call(\"get\",KEYS[1]) == ARGV[1] then return redis.call(\"del\",KEYS[1])else return 0end 为了避免误释放其他线程创建的锁是十分重要，比如一个客户端可能获得锁，因某操作所用时间超过锁有效时间（key失效的时间）而阻塞，而另外一个线程在此期间获得锁，然后删除此锁（注：把相同的key删除）。所以，仅仅使用DEL命令是不安全的，会删除其他客户端获得的锁。使用上述脚本，判断每个锁被一个随机的字串串做了标记，所以只有设置此key的客户端才能删除此锁。 随机字符串的值是什么？我假定是来自 /dev/urandom的20字节，不过你也可以使用其他的方式生成一个唯一的值。比如 在/dev/urandom中安全的挑选RC4种子，然后生成一个伪随机流。一个简单地方案：以毫秒为精度的unix系统时间拼接客户端ID，组成一个随机字符串的可以。虽然不完全安全，但在很多场景下是可以使用的。 key有效时间称之为“锁的有效时间”。它既是自动释放锁的时间，同时也是客户端在另外一个客户端再次获得此锁之前的操作时间，然而并没有在技术上确保互斥性，仅仅是给客户端获得锁的一个窗口时间。 到目前为止，由单个一直可用的实例构成的非分布式系统上，我们有一个好的方法获取和释放锁。让我们把此概念扩展到分布式系统中，而在分布式系统中，我们不能确保给出安全性和活跃性的保障。 Redlock算法 算法的分布式版本，我们假定有N个Redis主节点，这些节点完全独立，因此我们不使用复制或者其他隐式协作系统。我们已经描述了单节点下，如何安全地获得和释放锁。同时也保证了单实例中使用此方法获得和释放锁安全性和活跃性。示例中，我们假定N=5,它是一个合理的值。【为啥这么说？】因此，我们在不同机器或者虚拟机上运行5个Redis主节点，以确保他们若是宕了也是完全独立。 为了获得锁，客户端需要进行如下操作： 获得当前时间，以毫秒计；即为currentTimeInMs N个实例使用相同的key和随机值，顺序地尝试获得锁。在此步中，每个实例获取锁时，客户端会用一个超时时间，它比所有锁自动释放的时间小。比如，若自动释放锁时间为10s,那么超时时间在5ms~50ms之间。这样做事为了避免客户端为了等待一个宕机Redis节点，长时间处于阻塞状态：若一个实例不可用，我们会尽快与下一个实例“通话”。 客户端计算获得锁的时间，通过减去步骤1得到的当前时间。即为acqTimeInMS = acqLockCurrentTimeInMS-currentTimeInMs。当且仅当客户端从多个实例获得锁，设为n（n &gt;= N/2+1）;并且总共获得锁的时间为totalAcqTime，如果totalAcqTime小于锁的有效时间(intitValidtyTimeInMS),那么就认为客户端获得了锁。 若锁获得，那么有效时间validtyTimeInMS,可以认为是初始的有效时间减去步骤2中计算获得锁耗费的时间。 如果客户端因某种原因不能获得锁失败（不管客户端不能锁住N/2+1实例还是有效时间为负数），它将释放所有的实例（包括哪些客户端并没有获得锁的实例）。 所有步骤的伪代码如下： 123456789101112131415161718if n &lt; N/2+1 then noendfor i : n then acqTimeInMS = acqLockCurrentTimeInMS-currentTimeInMs totalAcqTime += acqTimeInMSendvalidtyTimeInMS = intitValidtyTimeInMS - totalAcqTimeif validtyTimeInMS &gt; 0 then yeselse noend if no then unlock all instance 算法是异步的吗？ 算法所依赖的假设，一个是进程之间没有同步时钟，每个进程中本地时间按照近似相同频率；另外一个是自动释放时钟存在一点小误差。这些假设近似一台真实地电脑：每台电脑都有本地时钟，同时我们一般依赖不同电脑之间存在一点时钟偏移。 基于此，我们需要制定我们互斥性规则：只要确保客户端所占锁将在锁有效时间（第三步所得）减去一定的时间（为了弥补进程间的是时钟偏移）。 有关相似系统需要一定的时钟偏移更多信息，可以参考此论文：Leases: an efficient fault-tolerant mechanism for distributed file cache consistency。 【疑问：依赖于系统时间，并非是个好事情，万一被改了呢？】 失败重试 当一个客户端不能够获得锁，它会等待一个随机时延之后重新获取。这么做事为了缓解多个客户端在同一时刻对同一个资源同时加锁（此种情况下可能会导致一个脑裂2问题使得谁也不能取胜）。另外，客户端从多个Redis实例获取锁的时间越快，脑裂发生的机会就越小。因此在理想情况下，客户端采用多路复用技术在同一时刻给N个实例发送SET命令。 需要强调的是，当客户端获取大部分的锁失败时，应尽快释放所获得的锁是如此的重要。是因为没有必要等待key过期之后再去获取锁（然而，如果发生网络分区和客户端不能与Redis实例通信，对于等待key过期，将会有一点可用性的惩罚）。 释放锁 释放锁十分简单，仅涉及到在所有实例中是否锁，不管怎么样，客户端相信能够成功地锁住一个实例。 安全性讨论 此算法是否安全？我们从不同场景来理解。 首先我们假设一个客户端已经从多个实例中获得锁。因此，所有的实例都包含一个相同时效的key。然而，key在不同的时刻设置的，所以会在不同的时间失效。若第一个key在T1时刻设置（假设时间在连接第一个实例），最后一个key在T2时刻设置（从最后一个实例返回的时间）；那么第一个key至少在MIN_VALIDITY=TTL-(T2-T1)-CLOCK_DRIFT之后时效，其他key将在MIN_VALIDITY之后失效。因此我们所有的key时效时间至少为MIN_VALIDITY。 在key设置期间，另外一个客户端不能获得锁，是因为N/2+1key已经存在，导致 N/2+1节点操作SET NX命令不会成功。所以，若一个锁已经被占用，那么在同一个时刻是不能被其他客户端占用的。（验证了互斥性） 然而我们也了解，多个客户端在同一时刻试图获取锁，不会相继成功的。若一个客户端锁住大多数实例耗费了相近，甚至比最大有效时间还大（使用SET命令设置的TTL），可以认为锁是失效的，并且会释放所有实例的锁，因此我们仅需要考虑的场景是一个客户端锁住大多数实例所用的时间比TTL小的情况。对于此场景，我们在上面已经计算了MIN_VALIDITY。在MIN_VALIDITY时间内，没有客户端能够重新获得锁。所以，多个客户端会在同一个时刻锁住N/2+1实例，若MIN_VALIDITY大于TLL,则锁是失效的。 你能为此提供一个形式化的证明或者指出现有那些类似的算法或者找出一个不管，我们为此十分感激。 活跃性讨论 系统活跃性基于下面三个主要特性： 锁的自动释放(因为key失效)：keys最终可以重新被锁住。 事实上，客户端会在获得锁失败时溢出锁，或者当锁被占用以及工作结束时，我们也没有必要等待锁失效才重新获取锁。 实际上，当一个客户端需要重新获得锁，它会等待一小段时间，此时间会比获得大多数锁的时间要长，以便减少在资源竞态下发生脑裂问题的概率。 在发生网路分区是，我们加罚一个等于TLL的惩罚时间，所以若是有持续的分区，我们可以让惩罚时无限大。此时，每个客户端移除锁之前，获取锁并且被分区化。 一般情况下，若长时间的网络分区，也会导致系统变得不可用。 性能、宕机恢复、文件同步 很多用户使用Redis作为一个锁服务器，获取锁和释放锁都是高性能，低时延的。同时，也需要在每秒中多次获取、释放锁。为了满足此需求，采用多路复用策略与N个Redis服务器通信以便减少时延（或者假定每个客户端与实例之间的RTT都相近，弱化多路复用以非阻塞的方式发送socket，发送所有的命令以及后面读取所有的命令）。 然而，如果我们想要实现“崩溃-恢复”系统模式，需要考虑另外一个持久化功能。 在此我们来看问题所在，我们假定Redis没有配置持久化，一个客户端从5个实例中获取了3个实例的锁，当其中某一台需要重启之后获得锁，此时还是从3个实例锁住相同的资源，其他客户端若能获得锁，那么将违背锁的互斥性原则。 假如我们设置了AOF持久化，事情就会变得好一点了。比如，我们通过发送 SHUTDOWN 命令和重启一台Redis服务器。因为Redis失效在语义上是实现的，所有当Redis服务停机时，key的有效时间也一直再慢慢流逝，所有的要求都是满足的。然而，只要Redis服务是干净的停下，那么一切都是好的。当断电的情况下又如何呢？若在默认情况下，配置Redis，让其每秒将数据同步到磁盘，那么重启一次服务，key就可能会丢失。理论上，若要不管任何情况下实例重启都保证锁是安全的，我们需要设置持久化模式为： fsync=always。这样的话，相比于同级别的分布式锁系统，性能会受到严重损害。 然而，初看起来事情比看起来要好一些。只要一个实例因崩溃后重启不在参与到任何一个活动的锁，那么当前活动锁集合会被实例锁住的而不是重新加入系统的实例占用，从保证了算法安全性。 为了保证这一点，我们一个实例，在比最大的TLL时间后仍然不可用，其中TLL是所有key有效时间，那么此实例就变得非法并且自动释放所有资源。 在不使用任何Redis持有化，使用延时重启在一般情况下能够实现安全性。但是需要注意的是，会转变为可用而受到惩罚时间。如果很多节点崩溃，系统将在TLL时间内变得全部不可用（全部的意思在TLL内，没有任何资源被锁住）。 让算法更可靠：扩展锁 如果客户端的工作是由一些小步骤组成的，那就可能使用默认的限制时间的小型锁，并实现锁扩展机制的算法。一般来说，如果客户端在计算过程的中途，而锁的有效期抵达了一个较小的值，那么就可能扩展锁机制。通过发送一个Lua脚本，通知所有实例，若key存在且对应的value值仍旧就是客户端获得锁之前的值，就让它们延长对应此Key的TTL值。 客户端仅需要考虑锁的重新获取，若客户端扩展锁可能在短时间内有大量的实例获得此锁。 虽然这并不是从技术的角度改变算法，因此重新获得锁的最大值是要限制的，否则一个活跃性就会遭到破坏。 需要帮助？ 如果你对分布式系统有深入的研究，若能提供你的观点或者分析，十分不错的。若能同时使用其他语言实现，也是不错的。在此表示感谢。 Redlock 的分析 Martin Kleppmann 分析的文章。我不是很同意他的意见，并且发表了 我对其分析的回应。 参考资料 1 : https://en.wikipedia.org/wiki/Failover 2 : https://en.wikipedia.org/wiki/Split-brain_(computing)","comments":true,"tags":[{"name":"array","slug":"array","permalink":"http://yoursite.com/tags/array/"},{"name":"distributed lock","slug":"distributed-lock","permalink":"http://yoursite.com/tags/distributed-lock/"},{"name":"redis","slug":"redis","permalink":"http://yoursite.com/tags/redis/"}]},{"title":"ARTS-7月3周","date":"2018-07-21T16:00:00.000Z","path":"2018/07/22/arts/7m3w-summary/","text":"7月3周ARTS总结 希望自己继续保持下去，分享第五个ARTS的内容： 1.A：按照类型做算法题，并复习算法。来源是leetco的算法题目Algorithm:88.Merge Sorted Array，倒着来的归并排序。 2.R：本周试着翻译RedisLock:Redis中的分布式锁，是关于Redis分布式锁实现。 3.T: 继续学习Linux，Linux 文件基本属性笔记 4.S: 开始学习Python，Python 列表操作","comments":true,"tags":[{"name":"ARTS","slug":"ARTS","permalink":"http://yoursite.com/tags/ARTS/"}]},{"title":"Linux 文件基本属性笔记","date":"2018-07-21T16:00:00.000Z","path":"2018/07/22/arts/tip/T-linux-file-basic-ma/","text":"缘由 最近学习linux系统中相关的命令，补一下这块知识。每次需要用相关的命令，都是各种搜索，并且不知道本后 的原理。 Linux 文件基本属性 使用 ls -l,查看的当前目录下地文件或目录。第一个字符代表这个文件是目录、文件或链接文件等等。 d:目录； -:文件； l:链接文档(link file)； b:装置文件里面的可供储存的接口设备(可随机存取装置)； c:装置文件里面的串行端口设备，例如键盘、鼠标(一次性读取装置)。 接下来的3组，每组以RWX或者-组合。 R:read； W:write； X:execute； -:RWX中没有权限。 第一组表示：文件的所有者的权限； 第二组表示：文件所属组的权限； 第三组表示：他用户拥有该文件的权限 更改文件相关属性的命令 更改文件属组： chgrp [-R] 属组文件名 更改文件属主，也可以同时更改文件属组：chown [–R] 属主名 文件名 或者 chown [-R] 属主名：属组名 文件名 更改文件9个属性：通过数字或者字符设置 Linux文件的基本权限就有九个，分别是owner/group/others三种身份各有自己的read/write/execute权限。 RWX-对应的数字：R:4;W:2;X:1;-:0 命令：chmod [-R] xyz 文件或目录, xyz是RWX-数字之和； 使用下面的命令\b操作： 命令 所有者 操作 文件或目录 chmod u +(加入) r g -(除去) w o =(设定) x a 其中，(1)u:user (2)g:group (3)o:others (4)a:all 参考资料 [Linux文件基本属性]：https://www.w3cschool.cn/linux/linux-file-attr-permission.html","comments":true,"tags":[{"name":"tip","slug":"tip","permalink":"http://yoursite.com/tags/tip/"},{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"}]},{"title":"Algorithm:Remove Element","date":"2018-07-14T16:00:00.000Z","path":"2018/07/15/arts/algorithm/A-remove-element/","text":"问题 Given an array nums and a value val, remove all instances of that value in-place and return the new length. Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory. The order of elements can be changed. It doesn’t matter what you leave beyond the new length. Example 1: Given nums = [3,2,2,3], val = 3, Your function should return length = 2, with the first two elements of nums being 2. It doesn’t matter what you leave beyond the returned length. Example 2: Given nums = [0,1,2,2,3,0,4,2], val = 2, Your function should return length = 5, with the first five elements of nums containing 0, 1, 3, 0, and 4. Note that the order of those five elements can be arbitrary. It doesn’t matter what values are set beyond the returned length. Level: Easy 解题思路 如果没有\bO(1)的空间复杂度，并且不关注修改后原来数组的结果。我们可以利用\bset\b或者map来解决此题。\b\b现在题目既然要求O(1)的\b空间复杂度解决，那么\b可以使用\b“双指针”的思路来解决此题,具体思路如下： 设pos为新数组下标值，初始化为0；\bidx为\b原数组的下标，\b[1, n); 若arr[pos] != arr[i],则 \barr[pos++] = arr[i] \b重复2，直到 i = n; 返回 新数组的长度：pos+1 \b详细代码如下： 12345678910111213public int removeElement(int[] nums, int val) &#123; if (null == nums || nums.length &lt;= 0) &#123; return 0; &#125; int len = nums.length; int pos = 0; for (int idx = 1; idx &lt; len; ++idx) &#123; if (nums[pos] != val) &#123; nums[++pos] = nums[idx]; &#125; &#125; return (pos + 1);&#125; 第一种解法保留了元素在数组中的顺序，题目也说明了可以改变数组的元素的位置，那么我们可以使用最后一位 元素来替换重复的元素。相关的代码如下： 12345678910111213141516public int removeElement2(int[] nums, int val) &#123; if (null == nums || nums.length &lt;= 0) &#123; return 0; &#125; int len = nums.length; int idx = 0; while (idx &lt; len) &#123; if (nums[idx] == val) &#123; nums[idx] = nums[len-1]; --len; &#125; else &#123; ++idx; &#125; &#125; return len;&#125; 复杂度分析 两种算法时间复杂度和空间复杂度如下： 时间复杂度为O(n),其中n为排序数组的长度； 空间复杂度为O(1)","comments":true,"tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://yoursite.com/tags/algorithm/"},{"name":"array","slug":"array","permalink":"http://yoursite.com/tags/array/"}]},{"title":"linux 磁盘管理的几个小命令","date":"2018-07-14T16:00:00.000Z","path":"2018/07/15/arts/tip/T-linux-file-command/","text":"linux 磁盘管理的小命令 工作上经常要清理一些文件以及查看磁盘的使用量，本周分享一下常用的几个磁盘管理命令。 df：列出文件系统的整体磁盘使用量 du：检查磁盘空间使用量，文件和目录磁盘使用空间 fdisk：用于磁盘分区","comments":true,"tags":[{"name":"tip","slug":"tip","permalink":"http://yoursite.com/tags/tip/"},{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"}]},{"title":"ARTS-7月2周","date":"2018-07-14T16:00:00.000Z","path":"2018/07/15/arts/7m2w-summary/","text":"7月2周ARTS总结 希望自己继续保持下去，分享第四个ARTS的内容： 1.A：按照类型做算法题，并复习算法。来源是leetco的算法题目Remove Element，利用“双指针”思想解决之。 2.R：分享一下本周看的英文文章:The Key to Accelerating Your Skills While You Learn to Code，是关于如何学习编程的文章，类似于十年编程。 3.T: 分享Linux下磁盘管理的命令 4.S: 分享从不中听的话中找到合理性","comments":true,"tags":[{"name":"ARTS","slug":"ARTS","permalink":"http://yoursite.com/tags/ARTS/"}]},{"title":"Review - The Key to Accelerating Your Skills While You Learn to Code","date":"2018-07-14T16:00:00.000Z","path":"2018/07/15/arts/review/R-the-key-to-code/","text":"概述 本周阅读了KEN MAZAIKA写的一篇文章《The Key to Accelerating Your Skills While You Learn to Code》1。主要讲解了如何快速学习编程，我们既要学习领域知识，也要学习过程知识。还有一点就是编程心态 和编程是一个持续性学习。作者将其分为三个阶段： 跟着手册学习或者练习阶段； 心态练习阶段，解决具体问题； 跳出舒适区 Tutorial phase（练习阶段） 此阶段就是跟着手册或者文档一步一步的走，注意文档提到细节，以及遇到的错误。主要完成： Learn domain-specific knowledge. Learn how to do specific task. 【放耐心解决遇到的问题，记录是什么原因导致的以及如何解决的。】 Building right mentality phase（构建心态阶段） Understand that this is a difficult process and go easy on yourself. If you’re struggling with self-confidence, know that what you’re feeling is completely normal. Keep working. Expanding skills（扩展阶段） Rather than trying to pull coding projects into your comfort zone, you should be seeking out problems that are outside your current skill set. Web development’s two inflection points（Web应用两个关键点） web开发的编程的两个转折点： mastering CRUD：\b熟练的编写与数据库操作相关的web应用； 算法 Write sorting algorithms Implement and reverse linked lists Understand and write programs leveraging stacks, queues, and trees Write computer programs using recursive or iterative solutions 认同的观点 Don’t sweat the stack. When you’re learning how to program, your singular goal should be to find the inflection point and annihilate it. Once you do, learning that new, sexy fad won’t be a difficult task at all. 【不跟风，快速找到转折点，也就是那些基础知识，然后消灭掉他们。】 Become self-reliant. 【碰到问题或者新的技术，学会自己去找食吃，而不是一直依赖于他人。】 Programming is a life-long learning experience. 参考资料 1.http://blog.thefirehoseproject.com/posts/learn-to-code-and-be-self-reliant/ ↩","comments":true,"tags":[{"name":"review","slug":"review","permalink":"http://yoursite.com/tags/review/"},{"name":"learning","slug":"learning","permalink":"http://yoursite.com/tags/learning/"}]},{"title":"Share：遇到不中听的话，也要找到合理之处","date":"2018-07-14T16:00:00.000Z","path":"2018/07/15/arts/share/S-self-think/","text":"背景 最近看吴军老师的《硅谷来信》，其中有一段讨论“即便遇到不中听的话，也要试着找出其中的合理之处。” 现在每次反思自己的行为都会想起这句话，现在每次听到不中听的话，都会反驳回去。对人对己都不是特别好， 今日将其摘抄一下，以便再次理解一次。 四层含义 “即便遇到不中听的话，也要试着找出其中的合理之处。”的四层含义： 换位思考 凡事要习惯回过头来三思。 可能觉得他是胡说八道 是否我错了，他对了 是否是我境界不够 即使对方真的是胡说八道，要思考它为什么这么说，找出其中的合理性 总之，每次遇到别人和我有不同意见时，就立即启动找对方合理性的开关。","comments":true,"tags":[{"name":"share","slug":"share","permalink":"http://yoursite.com/tags/share/"},{"name":"心智","slug":"心智","permalink":"http://yoursite.com/tags/心智/"}]},{"title":"Review《How you can improve your workflow using the JavaScript console》","date":"2018-07-06T16:00:00.000Z","path":"2018/07/07/arts/review/R-using-js-console/","text":"概述 本周分享review的文章是JavaScript中Console函数的使用，觉得很棒所以将其整理出来分享给大家。 Console的作用 JS中的console是每个浏览器必备的一个特性。它允许开发者： View a log of errors and warnings that occur on a web page. 查看出现在web页面中错误和警告 Interact with the web page using JavaScript commands. 使用JS命令与web页面进行交互 Debug applications and traverse the DOM directly in the browser 直接绕过DOM调试应用 Inspect and analyze network activity 监测和分析网络活动 调试类 使用如下函数，可以传入多个参数，它们会自动拼接，并以空格分隔，最终显示要查看的内容。 Console.log Console.error Console.warn Console.info 示例： 1234const niceJson = &#123;a:1, b:2, c:3&#125;;console.log(\"log\", niceJson, new Date());console.warn(\"warn\", niceJson, new Date());console.info(\"info\", niceJson, new Date()); 归类 使用console.group把log（或者info或者warn)归为一起。 示例： 12345678910111213function doSomething(obj) &#123; console.group('doSomething Profile'); const _data = new Date(); console.log('evauating data:', _data); const _fullName = `$&#123;obj.firstName&#125; $&#123;obj.lastName&#125;` console.log('fullName:', _fullName); const _id = Math.random(1); console.log('id:', _id); console.groupEnd();&#125;doSomething(&#123;\"firstName\":\"yun\", \"lastName\":\"feng\"&#125;); doSomething Profile evauating data: Sun Jul 08 2018 15:46:11 GMT+0800 (China Standard Time) fullName: yun feng id: 0.26763583139597613 数据表格化 可以使用console.table将对象或者对象数组表格化。 示例： 1234567const typeOfConsole = [ &#123;name:'log', type:'standard'&#125;, &#123;name:'info', type:'standard'&#125;, &#123;name:'table', type:'wow'&#125;];console.table(typeOfConsole); 结果： (index) name type 0 “log” “standard” 1 “info” “standard” 2 “table” “wow” 示例2： 123456789const mySocial = &#123; facebook:true, linkedin:false, flickr:false, instagram:true, Vkontaktebadoo:false&#125;;console.table(mySocial); (index) Value facebook true linkedin false flickr false instagram true Vkontaktebadoo false 统计类 测试函数的运行时间或者统计某一行代码执行的总数。 console.count console.time console.timeEnd 示例： 1234567891011console.time('total');console.time('init arr');const arr = new Array(20);console.timeEnd('init arr');for (var i = 0; i &lt; arr.length; ++i) &#123; arr[i] = new Object(); const _type = (i % 2 === 0) ? 'even' : 'odd'; console.count(_type + \" added\");&#125;console.timeEnd('total'); 结果： init arr: 0.003662109375ms even added: 1 odd added: 1 even added: 2 odd added: 2 even added: 3 odd added: 3 even added: 4 odd added: 4 even added: 5 odd added: 5 even added: 6 odd added: 6 even added: 7 odd added: 7 even added: 8 odd added: 8 even added: 9 odd added: 9 even added: 10 odd added: 10 total: 2.650146484375ms 堆栈跟踪类 console.trace console.assert 示例： 12345678910111213function lesserThan(a, b) &#123; console.assert(a &lt; b, &#123;\"message\":\"a is not lesser than b\", \"a\":a, \"b:\":b&#125;);&#125;lesserThan(6, 5);console.trace(\"End\");// resultVM634:2 Assertion failed: &#123;message: \"a is not lesser than b\", a: 6, b:: 5&#125;lesserThan @ VM634:2(anonymous) @ VM634:5VM634:6 End(anonymous) @ VM634:6 清除console 使用uglifyjs-webpack-plugin清除所有的console。 123456789101112131415161718192021const UglifyJsPlugin = require('uglify-webpack-plugin')var debug = process.env.NODE_ENV !== 'production'// ...optimization:&#123; minimizer:!debug ? [ new UglifyJsPlugin(&#123; // compression specific options uglifyOption: &#123; // Eliminate comments comments:false, compress: &#123; // removing warnings warnings:false, // drop console statements drop_console: true &#125;, &#125; &#125;)] :[]&#125; 总结 毕竟使用console是用来调试代码的，不能让这些代码上生产版本，所以需要注意之处。另外，就是在十分明确的地方就没有必要使用console,以免滥用误用。","comments":true,"tags":[{"name":"review","slug":"review","permalink":"http://yoursite.com/tags/review/"},{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"}]},{"title":"SLF4J 和 LOG4J","date":"2018-07-06T16:00:00.000Z","path":"2018/07/07/arts/tip/T-slf4jandlog4j/","text":"\b折腾背景 在公司开发都是使用内部框架的，使用打印日志没怎么关注过。本周在学习Srping的时候采用SLF4J和LOG4J打印日志。分享一下遇到的小问题以及解决方法。 SLF4J是啥 SLF4J是 Simple Logging Facade for Java简称，是为日志框架（比如，java.util.logging, logback 和 log4j）提供接口服务，具体日志打印是怎么实现有日志框架决定的。 小实验 下载SLF4J相关的JAR,引入到lass path。然后运行下面小程序: 123456789import org.slf4j.Logger;import org.slf4j.LoggerFactory;public class HelloWorld &#123; public static void main(String[] args) &#123; Logger logger = LoggerFactory.getLogger(HelloWorld.class); logger.info(\"Hello World\"); &#125;&#125; 会报如下错误: SLF4J: Failed to load class “org.slf4j.impl.StaticLoggerBinder”. SLF4J: Defaulting to no-operation (NOP) logger implementation SLF4J: See http://www.slf4j.org/codes.html#StaticLoggerBinder for further details. 不要担心，到这里说明你向前走了一步，把 slf4j-simple-1.8.0-beta2.jar,在运行一下就出现，你想要的结果了。 [main] INFO HelloWorld - Hello World 使用LOG4J 后面想打印Debug级别的日志，所以下载log4j的JAR包。下载后把其加入class path , 然后执行下面这个测试程序： 12345678910111213141516import org.slf4j.Logger;import org.slf4j.LoggerFactory;public class Wombat &#123; final Logger logger = LoggerFactory.getLogger(Wombat.class); Integer t; Integer oldT; public void setTemperature(Integer temperature) &#123; oldT = t; t = temperature; logger.debug(\"Temperature set to &#123;&#125;. Old temperature was &#123;&#125;.\", t, oldT); if(temperature.intValue() &gt; 50) &#123; logger.info(\"Temperature has risen above 50 degrees.\"); &#125; &#125; &#125; 输入 temperature 大于50则有日志，否则什么也没有。 Temperature has risen above 50 degrees. 然后把slf4j-log4j加入class path 下运行就报如下错误： SLF4J: Class path contains multiple SLF4J bindings. SLF4J: Found binding in [jar:file:/D:/tools/extraLib/log/slf4j-log4j12-1.7.25.jar!/org/slf4j/impl/StaticLoggerBinder.class] SLF4J: Found binding in [jar:file:/D:/tools/extraLib/log/slf4j-simple-1.7.25.jar!/org/slf4j/impl/StaticLoggerBinder.class] SLF4J: See http://www.slf4j.org/codes.html#multiple_bindings for an explanation. 先把slf4j-simple-1.8.0-beta2.jar移除，然后在src目前下新建log4j.properties，并敲入如下内容，用于配置log4j.properties和设置debug级别。 12345log4j.rootLogger=DEBUG, stdoutlog4j.appender.stdout=org.apache.log4j.ConsoleAppender log4j.appender.stdout.layout=org.apache.log4j.PatternLayout log4j.appender.stdout.layout.ConversionPattern=%c&#123;1&#125; - %m%n 最后运行，运行结果如下： Wombat - Temperature set to 20. Old temperature was null. Wombat - Temperature set to 60. Old temperature was 20. Wombat - Temperature has risen above 50 degrees. 为什么遇到上面两个问题，看到手册后面的文档说明就会明白,也是我们注意的地方。现摘录如下： To switch logging frameworks, just replace slf4j bindings on your class path. For example, to switch from java.util.logging to log4j, just replace slf4j-jdk14-1.8.0-beta2.jar with slf4j-log4j12-1.8.0-beta2.jar. SLF4J does not rely on any special class loader machinery. In fact, each SLF4J binding is hardwired at compile time to use one and only one specific logging framework. For example, the slf4j-log4j12-1.8.0-beta2.jar binding is bound at compile time to use log4j. In your code, in addition to slf4j-api-1.8.0-beta2.jar, you simply drop one and only one binding of your choice onto the appropriate class path location. Do not place more than one binding on your class path. 特别是下面张图，就会明了SLF4J的是干嘛的了，解决了啥问题。 小思考 阅读了一下manual，以及捣鼓了一下两个示例，对SLF4J有点小想法如下： SLF4J易于维护和升级 SLF4J是一个日志API，具体日志怎么整的是日志框架的事情，将日志与日志框架解耦，也即是后面如果项目需要升级比如将 LOG4J到LogBack。 高效且易于阅读 现在组里面都是使用+拼接打印的日志的，而SLF4J中可以使用占位符{},比如第二个例子就是。","comments":true,"tags":[{"name":"tip","slug":"tip","permalink":"http://yoursite.com/tags/tip/"},{"name":"slf4j","slug":"slf4j","permalink":"http://yoursite.com/tags/slf4j/"},{"name":"log4j","slug":"log4j","permalink":"http://yoursite.com/tags/log4j/"}]},{"title":"Share：grep命令查日志和日志内容乱码","date":"2018-07-06T16:00:00.000Z","path":"2018/07/07/arts/share/S-grep/","text":"grep命令查日志 本周突然接到通知，开发同事需要周六日轮流值班处理生产问题。本周六我做了支持。 查询日志的时候，使用最多的就是grep命令。周六碰到一个客户不能提前还款。 使用如下参数查找： 查询 关键字词 匹配所在的行：grep -n '关键字词' 文件 查询关键字词 前面或者后面多少行，grep -Anum1 -Bnum2 关键字词 文件 日志内容乱码 问题描述：使用grep找出的部分日志没有乱码，中文显示好的。而使用less命令 发现乱码，后面使用export LANG=zh_CN.UTF8;，仍旧没有解决问题。 最后使用export LESSCHARSET=latin1,解决乱码问题。可以参考less - Unix, Linux Command","comments":true,"tags":[{"name":"share","slug":"share","permalink":"http://yoursite.com/tags/share/"},{"name":"grep","slug":"grep","permalink":"http://yoursite.com/tags/grep/"}]},{"title":"ARTS-7月1周","date":"2018-07-06T16:00:00.000Z","path":"2018/07/07/arts/7m1w-summary/","text":"7月1周ARTS总结 希望自己继续保持下去，分享第三个ARTS的内容： 1.A：来源是leetcode在做了一个难点的算法题目Remove Duplicates from Sorted Array，利用排序数组的特性以及“双指针”思想解决之。 2.R：分享一下本周看的英文文章:How you can improve your workflow using the JavaScript consolen，是关于JavaScript中console函数的技巧。 3.T: 分享slf4和log4j入门。 4.S: 分享grep和less命令乱码。","comments":true,"tags":[{"name":"ARTS","slug":"ARTS","permalink":"http://yoursite.com/tags/ARTS/"}]},{"title":"Algorithm:Remove Duplicates from Sorted Array","date":"2018-07-06T16:00:00.000Z","path":"2018/07/07/arts/algorithm/A-Remove-Duplicates-from-Sorted-Array/","text":"问题 Given a sorted array nums, remove the duplicates in-place such that each element appear only once and return the new length. Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory. Example 1: Given nums = [1,1,2], Your function should return length = 2, with the first two elements of nums being 1 and 2 respectively. It doesn’t matter what you leave beyond the returned length. Example 2: Given nums = [0,0,1,1,1,2,2,3,3,4], Your function should return length = 5, with the first five elements of nums being modified to 0, 1, 2, 3, and 4 respectively. It doesn’t matter what values are set beyond the returned length. Level: Hard 解题思路 如果没有\bO(1)的空间复杂度，并且不关注修改后原来数组的结果。我们可以利用\bset\b或者map来解决此题。\b\b现在题目既然要求O(1)的\b空间复杂度解决，那么\b可以使用\b“双指针”的思路和排序数组的特性来解决此题,具体思路如下： 设pos为新数组下标值，初始化为0；\bidx为\b原数组的下标，\b[1, n); 若arr[pos] != arr[i],则 \barr[pos++] = arr[i] \b重复2，直到 i = n; 返回 新数组的长度：pos+1 \b详细代码如下： 12345678910111213public int removeDuplicates(int[] nums) &#123; if (null == nums || nums.length &lt;= 0) &#123; return 0; &#125; int len = nums.length; int pos = 0; for (int idx = 1; idx &lt; len; ++idx) &#123; if (nums[pos] != nums[idx]) &#123; nums[++pos] = nums[idx]; &#125; &#125; return pos + 1;&#125; 时间复杂度为O(n),其中n为排序数组的长度； 空间复杂度为O(1)","comments":true,"tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://yoursite.com/tags/algorithm/"},{"name":"array","slug":"array","permalink":"http://yoursite.com/tags/array/"}]},{"title":"ARTS-6月4周","date":"2018-06-28T16:00:00.000Z","path":"2018/06/29/arts/6m4w-summary/","text":"本周ARTS总结 6月最后一周的ARTS一直没有写完，主要原因有两点： 算法题目一直没有想到一个很好的想法解决； 这周家里和工作上都有很多事情，只能零碎的写写； 希望自己继续保持下去，分享第二个ARTS的内容： leetcode在做了一个难点的算法题目Median of Two Sorted Arrays，使用归并排序的算法解决之，但不是最好的，到目前还没有想到到最优解。 分享一下本周看的英文文章，主要是Peter Noring 和 Alan Skorkin的文章，主要是关于学习态度的问题，然后分享跟着MDN Web教程修改程序做成mntfun的介绍页面； 分享本周使用Junit测试多线程代码时，发现的一个小问题; 分享一下最近对TDD使用的一些小想法。","comments":true,"tags":[{"name":"ARTS","slug":"ARTS","permalink":"http://yoursite.com/tags/ARTS/"}]},{"title":"脚踏实地学习","date":"2018-06-28T16:00:00.000Z","path":"2018/06/29/arts/review/R-learn-by-hard-way/","text":"概述 本周阅读了Peter Norving 写的一篇文章《Teach Yourself Programming in Ten Years》1 和 Alan Sorkin 写的一篇文章《The Greatest Developer Fallacy Or The Wisest Words You’ll Ever Hear?》2 。这两篇文章给我的感触比较深，所以本周就分享一下文章大概内容以及本周根据 MDN一步一步做的一个mntfun静态页面。 态度：无捷径可走 主要讲我们学习编程所需要的态度不要企图一蹴而就，也不要好高骛远，没有捷径可走。 刻意练习 The key is deliberative practice: not just doing it again and again, but challenging yourself with a task that is just beyond your current ability, trying it, analyzing your performance while and after doing it, and correcting any mistakes. Then repeat. And repeat again. ** There appear to be no real shortcuts **: even Mozart, who was a musical prodigy at age 4, took 13 more years before he began to produce world-class music. In another genre, the Beatles seemed to burst onto the scene with a string of #1 hits and an appearance on the Ed Sullivan show in 1964. But they had been playing small clubs in Liverpool and Hamburg since 1957, and while they had mass appeal early on, their first great critical success, Sgt. Peppers, was released in 1967. 不要相信：用到的时候再学习，注意平时的积累； 两篇文章都提到要与高手一起合作，沟通； 保持激情 Maybe it is just that people don’t know how to build expertise (there is an element of truth to this), but I have a sneaking suspicion that it’s more about lack of desire rather than lack of knowledge. 成为程序员的步骤 我是一个初学者，没有啥资格说如何成为一个程序员，一个好的程序员，直接引用 Pert Noring的经验。如下： Get interested in programming, and do some because it is fun. Program. The best kind of learning is learning by doing. Talk with other programmers; read other programs. If you want, put in four years at a college (or more at a graduate school). Work on projects with other programmers. Learn at least a half dozen programming languages. Remember that there is a “computer” in “computer science”. Get involved in a language standardization effort. Have the good sense to get off the language standardization effort as quickly as possible. 分享mntfun介绍网页 本周业余时间跟着MDN开发网站3，学习web开发，主要是跟着入门教程，然后改写成mntfun一个介绍网 站。如下图，比较简陋。 参考资料 1.https://www.skorks.com/2011/02/the-greatest-developer-fallacy-or-the-wisest-words-youll-ever-hear/ ↩2.https://www.skorks.com/2011/02/the-greatest-developer-fallacy-or-the-wisest-words-youll-ever-hear/ ↩3.https://developer.mozilla.org/en-US/docs/Learn/Getting_started_with_the_web ↩","comments":true,"tags":[{"name":"review","slug":"review","permalink":"http://yoursite.com/tags/review/"},{"name":"learning","slug":"learning","permalink":"http://yoursite.com/tags/learning/"}]},{"title":"Algorithm:Median of Two Sorted Arrays","date":"2018-06-28T16:00:00.000Z","path":"2018/06/29/arts/algorithm/A-Find-median/","text":"问题描述 There are two sorted arrays nums1 and nums2 of size m and n respectively. Find the median of the two sorted arrays. The overall run time complexity should be O(log(m+n)). Example 1: nums1 = [1, 3] nums2 = [2] The median is 2.0 Example 2: nums1 = [1, 2] nums2 = [3, 4] The median is (2 + 3)/2 = 2.5 Level: Hard 解题思路与状态 问题分析 已知条件 两个排序数组，数组num1，元素个数为m；数组num2，元素个数为n； 问题 找到num1和num2的中位数 约束 算法的运行最坏时间为 O(log(m+n)) 解题思路 归并排序法 如果没有时间约束，就可以使用归并排序，若排序后的结果为nums3,元素个数为k=m+n;最终将问题转化为： 求数组nums3的中位数。 若k为奇数，直接为nums3[k/2]; 若k为偶数，则为(nums3[k/2]+nums3[k/2-1])/2； 此解法的时间复杂度为O(m+n),主要是归并排序上；空间复杂度为O(m+n)，用于暂存归并排序后的结果。 具体的代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445// find the median of a sorted arrrayprivate double findMedianSortedSignleArray(int[] nums) &#123; if (null == nums || 0 == nums.length) &#123; throw new IllegalArgumentException(\"sorted arrays are illegal.\"); &#125; int len = nums.length; if (0 == len % 2) &#123; return (nums[len/2] + nums[len/2 - 1]) / 2.0; &#125; return nums[len/2];&#125;public double findMedianSortedArrays(int[] nums1, int[] nums2) &#123; if (null == nums1 || 0 == nums1.length) &#123; return findMedianSortedSignleArray(nums2); &#125; if (null == nums2 || 0 == nums2.length) &#123; return findMedianSortedSignleArray(nums1); &#125; // using merge sort int n = nums1.length; int m = nums2.length; int[] mergeNum = new int[n + m]; int i = 0; int j = 0; int k = 0; while (i &lt; n &amp; j &lt; m) &#123; if (nums1[i] &gt; nums2[j]) &#123; mergeNum[k++] = nums2[j++]; &#125; else &#123; mergeNum[k++] = nums1[i++]; &#125; &#125; while (i &lt; n) &#123; mergeNum[k++] = nums1[i++]; &#125; while (j &lt; m) &#123; mergeNum[k++] = nums2[j++]; &#125; return findMedianSortedSignleArray(mergeNum);&#125; 递归算法 目前递归算法还未写出来，断断续续思考使用递归的想法有几天了，一直未果。现在留着不写，后续解决 之后在补上。 总结 对于使用递归算法解决此问题没能解决，内心是十分痛苦的。目前的思路是能否借助于二分查找算法解决， 最为关键的是递归结束的条件是什么。","comments":true,"tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://yoursite.com/tags/algorithm/"},{"name":"array","slug":"array","permalink":"http://yoursite.com/tags/array/"}]},{"title":"测试驱动开发小思考","date":"2018-06-28T16:00:00.000Z","path":"2018/06/29/arts/share/S-TDD-is-perfect/","text":"TDD疑问 最近学习TDD开发，用在平时开发的时候，就会发现TDD并不完美，特别是测试先行和各种需要覆盖 的测试。存在疑问如下： 是否真的需要一开始就写测试，然后一步一步驱动去开发呢； 后续测试用例的维护，特别与关联其他部门的接口，各种mock和stub； 耗费的时候比先写好代码再测试更大； 一些观点 对TDD有一些不成熟的想法，不一定非等需要严格按照TDD开发流程进行项目开发，找到适合自己的就行。TDD 对我来说很难掌握，但可以从TDD中学习和借鉴的是： 开发自己列好测试清单，以便我们单元测试做得足够； 重构自己写的代码； 后面在StackoverFlow上看到一个帖子How deep are your unit tests?，附上问题和比较喜欢的答案： 问题 The thing I’ve found about TDD is that its takes time to get your tests set up and being naturally lazy I always want to write as little code as possible. The first thing I seem do is test my constructor has set all the properties but is this overkill? My question is to what level of granularity do you write you unit tests at? …and is there a case of testing too much? 比较喜欢的两个回答： TDD创始人Kent Beck回答： I get paid for code that works, not for tests, so my philosophy is to test as little as possible to reach a given level of confidence (I suspect this level of confidence is high compared to industry standards, but that could just be hubris). If I don’t typically make a kind of mistake (like setting the wrong variables in a constructor), I don’t test for it. I do tend to make sense of test errors, so I’m extra careful when I have logic with complicated conditionals. When coding on a team, I modify my strategy to carefully test code that we, collectively, tend to get wrong. Different people will have different testing strategies based on this philosophy, but that seems reasonable to me given the immature state of understanding of how tests can best fit into the inner loop of coding. Ten or twenty years from now we’ll likely have a more universal theory of which tests to write, which tests not to write, and how to tell the difference. In the meantime, experimentation seems in order. kitofr的回答 Everything should be made as simple as possible, but not simpler. - A. Einstein One of the most misunderstood things about TDD is the first word in it. Test. That’s why BDD came along. Because people didn’t really understand that the first D was the important one, namely Driven. We all tend to think a little bit to much about the Testing, and a little bit to little about the driving of design. And I guess that this is a vague answer to your question, but you should probably consider how to drive your code, instead of what you actually are testing; that is something a Coverage-tool can help you with. Design is a quite bigger and more problematic issue. 后来看到耗子叔写了一篇TDD并不是看上去的那么美,比我写的好，思考的深。 另外关于Unit test VS TDD讨论也是十分精彩的，推荐阅读。","comments":true,"tags":[{"name":"TDD","slug":"TDD","permalink":"http://yoursite.com/tags/TDD/"},{"name":"share","slug":"share","permalink":"http://yoursite.com/tags/share/"}]},{"title":"Junit测试Java多线程小疑","date":"2018-06-28T16:00:00.000Z","path":"2018/06/29/arts/tip/T-java-thread-unit/","text":"遇到背景 本周分享一个小问题，在看TIJ（Java编程思想）中多线程机制一节时，把书中的示例使用Junit来测试。发 现与书中使用main方法来测试的结果是不一样的。 问题描述 为了描述问题，先引用书中的例子：定义一个简单地任务，代码如下： 123456789101112131415161718192021public class LiftOff implements Runnable &#123; protected int countDown = 10; private static int taskCount = 0; private final int id = taskCount++; public LiftOff() &#123;&#125; public LiftOff(int countDown) &#123; this.countDown = countDown; &#125; public String status() &#123; return \"#\" + id + \"(\" + (countDown &gt; 0 ? countDown : \"liftoff!\") + \"),\"; &#125; @Override public void run() &#123; while (countDown-- &gt; 0) &#123; System.out.println(status()); Thread.yield(); &#125; &#125; &#125; 使用Junit测试代码如下： 123456789@Testpublic void testMoreBasicThread() throws InterruptedException &#123; for (int i = 0; i &lt; 5; ++i) &#123; Thread t = new Thread(new LiftOff()); //t.join(); t.start(); &#125; System.out.println(\"Waiting for LiftOff\");&#125; 使用main测试的结果与Junit测试的结果相比对，就会发现两者不同。 main函数测试的结果 Waiting for LiftOff#0(9),#0(8),#0(7),#0(6),#0(5),#0(4),#0(3),#0(2),#0(1),#0(liftoff!), Junit测试的结果 Waiting for LiftOff#0(9),#0(8),#0(7),#0(6),#0(5),#0(4),#0(3),#0(2), 为什么使用Junit输出的结果会比使用main方法直接测试的要少。 分析与解决 一般情况下，只有当所有的守护线程完结之后JVM才会结束。为此，你可以在执行任务的线程上调用 t.setDaemon(false)来防止JVM在任务未执行完成之前就结束生命了。但是Junit会在主线程结束时调用 System.exit()。具体的见JunitCore.java中代码，下面是与此问题相关的代码1。解决方法就是在 调用t.start()之前调用t.jion(),让Junit线程等待任务的完成2。 123public static Result runClasses(Class&lt;?&gt;... classes) &#123; return runClasses(defaultComputer(), classes);&#125; 参考资料 1.https://github.com/junit-team/junit4/blob/master/src/main/java/org/junit/runner/JUnitCore.java#L48 ↩2.https://stackoverflow.com/questions/16616590/thread-behaving-strangely-in-junit ↩","comments":true,"tags":[{"name":"junit","slug":"junit","permalink":"http://yoursite.com/tags/junit/"},{"name":"thread","slug":"thread","permalink":"http://yoursite.com/tags/thread/"},{"name":"tip","slug":"tip","permalink":"http://yoursite.com/tags/tip/"}]},{"title":"测试驱动开发笔记之入门","date":"2018-06-22T16:00:00.000Z","path":"2018/06/23/arts/share/S-TDD-note/","text":"无意间接触TDD 以前写个小函数之后，一直用main函数来做单元测试。看看是否有其他的方法，不用老这么整。 后面听到过xUnit啥，然后在网上也看一部分资料，Junit简要入门,junit-tutorials等。 弄完之后觉得好奇，想知道Junit是谁先提出的，无意间就找到 Kent Beck 的一本关于测试驱动开发的书： 《Test-Driven Development By Example》。 TDD 小结 后面每天抽点时间把第一章的知识看完，主要围绕资金实例一步一步的介绍测试驱动开发，作者忒细心， 深怕介绍的过快而没有讲清楚。今日把相关的要点列出来，最近慢慢在开始练习开发模式写代码。示例代码 可以参考TDD。 测试驱动开发的目标 每一种开发方法都是为了解决某个问题而来的，而测试驱动开发的目的就是为让人写出整洁可用的代码。 测试驱动开发的态度 测试优先 只有自动测试失败时，才重写代码 不可运行/可运行/重构 不断构建测试列表 测试驱动开发的过程 加入一个小的测试； 运行所有测试，运行测试； 适当修改; 运行测试且成功; 重构，消除重复设计，优化设计结构。 三个测试驱动开发小技巧 让测试利落运行的三种方法 伪方法:返回一个常量并逐渐用变量代替常量，直至伪实现代码成为真实地代码 三角法：在例子达到2个或更多时才对代码实施一般化 显明实现：实现真实的代码 把消除代码与测试间的重复设计作为驱动设计的一种手段 控制测试间隙的能力，不知如何下手，就放慢，在状况好时就开快一些 参考资料 http://www.vogella.com/tutorials/JUnit/article.html http://www.mkyong.com/tutorials/junit-tutorials/","comments":true,"tags":[{"name":"TDD","slug":"TDD","permalink":"http://yoursite.com/tags/TDD/"},{"name":"share","slug":"share","permalink":"http://yoursite.com/tags/share/"}]},{"title":"Review:多兴趣成功以及5小时法则","date":"2018-06-22T16:00:00.000Z","path":"2018/06/23/arts/review/R-mutil-interests/","text":"概述 本周阅读了多兴趣与成功以及5小时法则，将其中要点以及自己的感悟分享给大家。 多兴趣与成功 《People Who Have “Too Many Interests” Are More Likely To Be Successful According To Research》一文表明的观点是在现在或者未来，通才更容易成功。读完之后有如下感触： 多视角看问题，更容易解决复杂问题； 保持好奇心，心态要开放不要鄙视或者轻视任何新事物； 学习的东西必须用起来； 读完此文还有吴军老师的《见识》中关于跨界的介绍。加上自己这几年读书和近一年的工作经历，这也想学习， 那也想学习，但是啥没有深入进去。都是学了点皮毛。就如同猴子摘棒子一般。培养的兴趣要为某个核心领域 服务，能够将兴趣结合在一起才行。所以给我自己的告诫： 不要过多兴趣，除非那些天赋和精力超级旺盛的人； 读书或者做事情一定要持续投入； 5小时法则 5小时法则的来源是富兰克林，他每日都抽取至少1小时投入学习，每周5个小时。作者也列举了很多例子： Warren Buffett spends five or six hours per day reading five newspapers and 500 pages of corperate reports. Bill Gates reads 50 books per year. Mark Cuban read more than 3 hours every day. Mark Zuckerberg reads at least one book two weeks. … 作者建议如下： Reading：每日不断阅读； Refection： 反思所学以及自己的行为； Experimentation: 解决遇到的问题，利用你学到知识。 Don’t be lazy. Don’t make excuses. Just get it done. 参考资料 Why Constant Learners All Embrace the 5-Hour Rule Bill Gates, Warren Buffett And Oprah All Use The 5-Hour Rule 5-Hour Rule: If you’re not spending 5 hours per week learning, you’re being irresponsible People Who Have “Too Many Interests” Are More Likely To Be Successful According To Research 吴军 《见识》关于跨界的介绍","comments":true,"tags":[{"name":"review","slug":"review","permalink":"http://yoursite.com/tags/review/"},{"name":"5小时法则","slug":"5小时法则","permalink":"http://yoursite.com/tags/5小时法则/"},{"name":"兴趣","slug":"兴趣","permalink":"http://yoursite.com/tags/兴趣/"}]},{"title":"Algorithm:Two Sum","date":"2018-06-22T16:00:00.000Z","path":"2018/06/23/arts/algorithm/A-TwoSum/","text":"问题描述 Given an array of integers, return indices of the two numbers such that they add up to a specific target.You may assume that each input would have ** exactly one solution**, and you may not use the same element twice. Example Given nums = [2, 7, 11, 15], target = 9, Because nums[0] + nums[1] = 2 + 7 = 9, return [0, 1]. 解题思路与状态 当时看完题目给自己定了一个30分钟的闹钟，可以在这段时间中搞定它。存在疑问： 若数组排序，可以使用两边夹方法解决之；若不是怎么处理。 数组中是否存在重复元素，若有怎么处理。 未找到满足条件的元素，是抛出异常还是给定特殊的标志，比如[-1,-1]。 看完题目之后头脑中形成的解题思路暴力破解法，一下搞完，本地测试通过了，时间复杂度为 O(n^2)。 不是自己想要的结果，接着想能都把元素的值与下标对应起来，然后再去查找，利用空间换时间，以缩短查询 时间。后面出现了使用hashmap做处理的元素值，这种情况在数组中存在重复元素有问题。后面想了很久 仍旧没有想到使用一个hashmap来解决此问题。这个时候已经过去40分钟，心里面开始出现焦急状态， 无奈之下看答案了。两种hashmap的方法的空间复杂度为O(n),时间复杂度为O(n)。下面就将每个 解法的关键点列出来。 暴力破解法 1234567891011121314public int[] twoSum(int[] nums, int target) &#123; if (null == nums || nums.length &lt;= 1) &#123; return new int[] &#123;-1, -1&#125;; &#125; int len = nums.length; for (int i = 0; i &lt; len; i++) &#123; for (int j = i + 1; j &lt; len; j++) &#123; if (nums[j] == target - nums[i]) &#123; return new int[] &#123; i, j &#125;; &#125; &#125; &#125; return new int[] &#123;-1, -1&#125;;&#125; 双哈希法 1234567891011121314151617public int[] twoSum(int[] nums, int target) &#123; if (null == nums || nums.length &lt;= 1) &#123; return new int[] &#123;-1, -1&#125;; &#125; Map&lt;Integer, Integer&gt; map = new HashMap&lt;Integer,Integer&gt;(); int len = nums.length; for (int i = 0; i &lt; len; i++) &#123; map.put(nums[i], i); &#125; for (int i = 0; i &lt; len; i++) &#123; int right = target - nums[i]; if (map.containsKey(right) &amp;&amp; map.get(right) != i) &#123; return new int[] &#123; i, map.get(right) &#125;; &#125; &#125; return new int[] &#123;-1, -1&#125;;&#125; 单哈希法 1234567891011121314public int[] twoSum(int[] nums, int target) &#123; if (null == nums || nums.length &lt;= 1) &#123; return new int[] &#123;-1, -1&#125;; &#125; Map&lt;Integer, Integer&gt; map = new HashMap&lt;Integer,Integer&gt;(); for (int i = 0; i &lt; len; i++) &#123; int right = target - nums[i]; if (map.containsKey(right)) &#123; return new int[] &#123; i, map.get(right) &#125;; &#125; map.put(right, i); &#125; return new int[] &#123;-1, -1&#125;;&#125; 总结 以后做算法题或者解决难题的时候，要懂得放一放，不要非得在一定的时间之内完成，特别是在做算法题。 毕竟在leetcode上做算法题不是为了刷题目，而是为了锻炼自己的思维还有夯实算法知识。","comments":true,"tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://yoursite.com/tags/algorithm/"}]},{"title":"简单线上bug以及处理流程","date":"2018-06-22T16:00:00.000Z","path":"2018/06/23/arts/tip/T-onlineproblem/","text":"一个bug背景 在周三快下班的时候，临时接到需求，需要修改协议书模板，后端只需要修改脚本即可。由于周四是版本 上线的最后一天，所以建议不要修改，原因如下： 每次发版当天的环境会很差，各个关联方环境极其不稳定； 本身有很多需求都没全部覆盖测试； 改完之后都需要走回归测试，测试同事有时间么； 但是组长觉得小小需求，测试负责人也说支持。最后妥协，修改了，当天就搞定了。周四开始回归测试，测试 同事测试出一个bug了，为说明此bug产生的缘由，说明一些简称： 1.客户级别L：（0：低；1：高）; 2.数据源： 客户OCR扫描完证件信息（A） 本地数据库（B） 客户预留信息（C） 关系方的信息（D） 3.渠道：A 和 B 需求做一个比对，判断是否同一个人，此需求是小灰同事负责开发（同事之间需要和谐相处说，随意取名小 灰。 ），在此将简单写成伪代码，如下： 12345678910111213141516171819202122232425262728293031 res = false // 块1 if A then if A == B then res = true else res = false END END// 块2 if L == 0 then // 块2.1 if D 存在 then if A == D then res = true else res = false END else res = true END // 块2.2 else if A == C then res = true else res = false END END return res 周四测试同事发现低级别的客户，OCR扫的与本地库不同，居然也认为是本人，所以将bug给小灰和我。当 时我看着日志，把数据对比的数据拿出来，写单元测试，发现确实如此。然后就叫小灰过来，给他讲了一下， 发现的问题，A渠道来的在块1比较是不同的人，客户又是低级的而D数据不存，覆盖了之前校验的值，将其 变为是本人了。后面他说：“不是很明白，回桌上自己想想”。最后他说改完了，移交测试了。由于我负责其 他的需求开发，负责查日志，忙着就忘记去看小灰怎么改的。后面就上线了，由于小灰需要支持版本发布， 周五调休。 另一个bug背景 周五一上班，大概10点多，收到很多邮件，一会查这个一会查另外一个。当天看到6笔报不是本人的异常， 赶紧查日志。拉取最新的代码，查完分析代码。小灰修改后的代码，改写伪代码如下： 1234567891011121314151617181920212223242526272829303132res = false // 块1 if A then if A == B then res = true else res = false END END// 块2 if L == 0 then // 块2.1 if D 存在 then if A == D then res = true else res = false END //else // 小灰修改处 // res = true END // 块2.2 else if A == C then res = true else res = false END END return res 分析出来是，B渠道，低级别客户，在数据D不存在的情况下，一直是非本人。所以与测试沟通造相关的数 据，复现生成问题。 bug修复处理 最后跟领导申请紧急版本处理修复，由于是由一个bug引起bug，问了如下三个问题： 修改的代码是否有review 测试同事是否有案例review 是否负责人报备 我的回答都是否定的，当时发现第一个bug的时候，我跟测试负责人打了招呼，但是没有跟组长说，后面也没 有review小灰修改的代码。处理此事我司步骤如下： 发邮件申请紧急版本给部门长； 开发直属领导与部门长说明bug问题； 修复bug 测试回归 发布版本 生成验证 修改小灰的代码如下： 12345678910111213141516171819202122232425262728293031res = false // 块1 if A then if A == B then res = true else return false // 修1 END END// 块2 if L == 0 then // 块2.1 if D 存在 then if A == D then res = true else return false // 修改2 END else // 修改3 仍旧加上 res = true END // 块2.2 else if A == C then res = true else res = false END END return res 然后与组长一起review代码，影响业务比较大，所以需要快速解决，没有重构代码。好了之后，画好流程 图，给测试同事讲解，再告诉测试同事在测试环境造什么样的数据，让其一个分支一个分支的测试。上线之 后，自己又找人生产验证。 总结 问责的时候，心里面确实不舒服，不是我的错，为啥要我承担。 后面想想，自己也有责任，发现了bug， 没有和小灰一同修复。今天就把此两个bug回顾，总结如下： 复杂的业务逻辑画好流程图，与测试同事一同案例评审； 开发单元测试一定做足； 不要逃避责任。","comments":true,"tags":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"},{"name":"Tip","slug":"Tip","permalink":"http://yoursite.com/tags/Tip/"}]},{"title":"ARTS之旅","date":"2018-06-22T16:00:00.000Z","path":"2018/06/23/arts/6m3w-summary/","text":"本周ARTS总结 ARTS是左耳朵耗子发起的一个活动，具体如下： Algorithm：每周至少做一个leetcode的算法题; Review：阅读并点评至少一篇英文技术文章； Tip/Techni：学习至少一个技术技巧； Share：分享一篇有观点和思考的技术文章； 你需要坚持至少一年！ 在微信群里面看到此活动的时候，晚上还失眠了，回想自己读书以及工作一年，没有什么习惯坚持下来， 都是两天打鱼三天晒网。现在一直都生活在舒适区或着看了比较多材料也没有什么输出，内心忒崩溃， 越想越烦躁，最后失眠了,后面想将ARTS作为自己的一个项目去维护，既然遇到左耳朵耗子哥，有契机， 就好好把握，也想看看自己能走多远，也希望藉此机会好好锻炼自己。想那么多，又不能改变啥，去做就是。 我自己理解的ARTS目的 A:我学习比较浮躁，夯实以前看算法书，锻炼一下自己的思维能力； R:督促自己学习英语，去总结和思考； T:不要放弃技术，相信技术，积累； S:学会分享，与人沟通，而不是一个人独自学习； 总之，积少成多，说了这么多，该谈谈本周开启ARTS之旅，分享的内容如下： leetcode在做了一个简单地算法题目Two Sum，给定一个数组和一个值，找出两个值之和等于给定的值； 分享一下本周看的英文文章，主要是多兴趣以及一周5小时法则； 分享本周遇到一个简单线上bug以及处理流程; 本周学习TDD开发，分享一下阅读测试驱动开发笔记一; ARTS活动内容来源：左耳朵耗子 20180615 发得的微博。","comments":true,"tags":[{"name":"ARTS","slug":"ARTS","permalink":"http://yoursite.com/tags/ARTS/"}]},{"title":"mock和RAP入门教程","date":"2017-07-30T16:00:00.000Z","path":"2017/07/31/mock-rap-basic-uasge/","text":"在很早以前公司里面就接入了rap在线管理接口文档平台，通过图形化书写接口文档，给前端同事使用。但是之前也仅仅是用于写接口文档，从来没有研究过它还有其他用途。最近与自己合作的一个前端同事说，你为啥不利用好rap来写接口文档，它会自动生成mock数据，我们就不用将rap默认生成的数据修改后，再本地测试一下。弄完之后再与你们联调。今儿就花了2个小时左右研究一下rap，顺藤摸瓜出来mock。下面简单介绍一下，mock以及如何在rap中使用mock，生成比较好的模拟数据，提高前后端协作效率。 mock.js1 mock.js随机生成数据，让前端开发人员在开发阶段时独立于后端，使用mockjs可以自测代码。 语法规范 数据模板定义规范(DTD:Data Template Definition) 数据占位符规范(DPD: Data Placeholder definition) 数据模板定义规范 格式 'name|rule':value (属性名|生成规则:属性值)，其中生成规则是可选的 生成规则 7种生成规则 'name|min-max':value 'name|count':value 'name|min-max.dmin-dmax':value 'name|+step':value 'name|min-max.dcount':value 'name|count.dmin-dmax':value 'name|count.dcount':value 生成规则的含义依赖属性值的类型才能确认，这一点特别重要。也是mock的关键所在。 比如： 'name|min-max':string: 通过重复[min,max]次string生成新字符串。 'name|min-max':number: 生成一个number，返回在[min,max]。 属性值 属性值可含@（占位符） 指定最终的值和类型 属性值类型 String Number Boolean Object Array Function RegExp Path 学过js看着十分简单，只是多了RegExp 和 Path，其他简直一模一样。 数据占位符定义规范DPD 占位符 1.占位符只是在属性字符串中占个位置，并不出现在最终的属性值中 2.格式：@占位符或者@占位符(参数[,参数]) 3.占位符 用@标识后面的字符串是占位符 引用的是Mock.Random中的方法 扩展定义占位符：Mock.Random.extend() 引用数据模板中的属性 支持相对路径和绝对路径 4.数据占位符类型 数据占位符一共有如下几种类型： Basic Date Image Color Text Name Web Address Helper Miscellaneous 具体mock语法示例，请参考mock示例2，里面详细的介绍了各个类型使用方法。 rap写接口文档中运用mock3 什么是rap RAP是前后端沟通桥梁的通信接口，是一个图形化的接口文档管理的软件。它可以自动生成mock数据，在开发时候前端同事可以不依赖于后端的数据，而是根据mock规则自动生成的模拟数据进行测试。 怎么在rap中是使用mock 有很多资料，且是图文并茂写博文4,5。总结起来，在rap中运用mock方法如下： 左边变量写 name|rule，此处相当于就是mock中的'name|rule'; 右边备注写 @mock=value。其语法规则mock一样。 1.https://github.com/nuysoft/Mock/wiki ↩2.http://mockjs.com/examples.html ↩3.https://github.com/thx/RAP/wiki/ ↩4.http://www.imooc.com/article/17588 ↩5.http://blog.sina.com.cn/s/blog_c00ccc680102x0ue.html ↩","comments":true,"tags":[{"name":"mock","slug":"mock","permalink":"http://yoursite.com/tags/mock/"},{"name":"RAP","slug":"RAP","permalink":"http://yoursite.com/tags/RAP/"}]},{"title":"python实现http发送POST请求","date":"2017-07-24T16:00:00.000Z","path":"2017/07/25/python-http-post/","text":"现在开发是前后端完全分离的，在公司里面很多接口都和登陆态相关联起来。从而使得我在需求开发的时候依赖于前端同事打包完之后才开始测试自己的需求功能。所以比较耗费时间和精力。但是我们的服务接口是不依赖登陆态的，为了测试自己的服务接口，需要模拟发送HTTP请求，以便后面偷懒。本文就此介绍一下如何解决此问题。 语言选择以及依赖包 为了能够快速解决此问题，首先需要找到合适的工具，俗话说，“工欲善其事，必先利其器。” 在程序设计中首先就是语言的选择，相比于java，对python更为熟悉一点。说句皮外话， 虽然在公司用java开发，但是对java熟悉程度不如python,汗颜啦。回归正题，选好了 语言之后，紧接着就是如何模拟发送HTTP请求。google一番找到一个第三方包urllib3。 如何安装urllib3以及使用文档教程。 实现 现在我们来看看，如何使用urllib3包来模拟发送HTTP的POST请求，请求参数是JSON格式。为了能够使用urllib3模块，需要在使用导入urllib3模块，代码：import urllib3。使用PoolManager 实例来发送请求，它已经为我们封装处理好了连接池以及线程安全问题，我们没有必要再次徒手开发一套。其实，urllib3中最为核心关键的方法是request方法，它指定发送请求的方式、请求地址请求的参数。具体步骤如下： 指定请求方法以及url; 将请求的参数编码，然后作为body的值; 设置请求头部的Content-Type为JSON格式. 下面是一个示例代码： 12345678910111213#-*- coding:utf-8 -*-import urllib3from urllib import urlencodeimport jsondef testEsaInterface(url, param): http = urllib3.PoolManager() try: r = http.request('POST',url, body=json.dumps(param).encode('utf-8'),headers=&#123;'Content-Type': 'application/json'&#125;) if r.status == 200: print r.data except urllib3.exceptions.MaxRetryError as e: print repr(e) 如果想对返回的结果进行处理，先将返回的数据进行解码以及反序列化，可以使用decode函数解码，loads函数反序列化。然后采用类似于下标的访问方式获取相关字段的值。示例代码如下： 123res = json.loads(r.data.decode('utf-8'))if (\"906\" == res['data']['returnCode']): # to do something 下图是我测试人脸识别功能一个测试结果： postman发送post请求 弄完工具之后，本来想再做一个网页版的，后面发现chrome中有一个插件postman, 可以解决我的问题，突然发现重复造轮子咯。下面简单介绍一下，如何用postman发送 post请求，其中请求的参数为JSON格式。步骤如下： 选择发送请求的方式为 POST; 输入访问的URL 在headers标签页输入 Content-type, 对应的值为 application/json; 在body标签页面，选择raw,然后在输入JSON格式的请求参数; 最后点击send按钮即可. 是不是发现很简单，如果你觉得还是不清楚,可以参考此博文。 本文仅仅简单介绍了urllib3模块发送HTTP的POST请求方式，还有很多功能需要大家自己去发掘。 参考 安装urllib3: https://pypi.python.org/pypi/urllib3/ urllib3的使用教程: https://urllib3.readthedocs.io/en/latest/user-guide.html postman以JSON格式发送POST请求: http://www.cnblogs.com/shimh/p/6093229.html","comments":true,"tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"},{"name":"http","slug":"http","permalink":"http://yoursite.com/tags/http/"}]},{"title":"sicp 数据对象之集合操作","date":"2017-07-21T16:00:00.000Z","path":"2017/07/22/sicp-dataobject-set/","text":"本文主要介绍不同的数据抽象，对应用程序在使用公共函数时会造成何种影响。这里主要是使用集合使用三种数据来表示：集合作为未排序的表、集合作为排序的表、集合作为有序二叉树，探讨不同的数据对象形式表示集合时，对使用集合的程序性能的影响。 基本概念 选择函数与构造函数 构造函数：说明一个数据对象是由哪些原始组成的。 选择函数：怎么将数据对象中的组成元素抽取出来。 数据抽象定义 数据定义就是一组选择函数与构造函数，以及为了使它们成为一套合法的表示。因此它们需要满足一组特定的条件。 看着上面两个定义是不是很拗口，不知道在说啥。举个例子来说，如果一个有理数p是由整数 n 和 整数 d 构造而成。也就是 p = n /d。 12345;构造函数 p = n / dp = (make-rat n d);选择函数n = (numer p)d = (denom p) 集合操作 在高中的数学我们学习过，集合表示一组无重复的元素聚集而成。在数据结构中，集合表示一组具有相同属性的元素，并且满足数学中的集合属性：无序性。 常见集合的操作，判断某个元素是否属于某个集合、求两个集合的交集、求两个集合的并集。假设集合A={1,2,3}、B={2,3,4}，以及元素m=2,n=5，则： 判断某个元素是否属于某个集合：m 属于A,也属于B，而n不属于A,也不属于B; A 与 B 的交集为：{2, 3}; A 与 B 的并集为：{1, 2, 3, 4} 下面我们来看看使用三种不同的数据表示，会对写集合常见操作造成什么样影响。 集合作为未排序的表 构造函数与选择函数 直接使用list 函数，但是集合中元素是排序的，比如集合A={1, 10, 2, 4, 3}。 判断某个元素是否属于某个集合 1234(define (element-of-set? x set) (cond ((null? set) #f) (else (or (equal? x (car set)) (element-of-set? x (cdr set)))))) 求两个集合的交集 12345(define (intersection-set set1 set2) (cond ((or (null? set1) (null? set2)) &apos;()) ((element-of-set? (car set1) set2) (cons (car set1) (intersection-set (cdr set1) set2))) (else (intersection-set (cdr set1) set2)))) 求两个集合的并集 123456(define (union-set set1 set2) (cond ((null? set1) set2) ((null? set2) set1) ((element-of-set? (car set1) set2) (union-set (cdr set1) set2)) (else (cons (car set1) (union-set (cdr set1) set2))))) 将某个元素加入集合中 1234(define (adjion-set x set) (if (element-of-set? x set) set (cons x set))) 集合作为排序的表 构造函数与选择函数 直接使用list 函数，但是集合中元素是排序的，比如集合A={1, 2, 3, 4, 5, 10}。 判断某个元素是否属于某个集合 12345(define (element-of-set? x set) (cond ((null? set) #f) ((equal? x (car set)) #t) ((&lt; x (car set)) #f) (else (element-of-set? x (cdr set))))) 求两个集合的交集 12345678(define (intersection-sort-set set1 set2) (if (or (null? set1) (null? set2)) &apos;() (let ((x (car set1)) (y (car set2))) (cond ((= x y) (cons x (ntersection-sort-set (cdr set1) (cdr set2)))) ((&lt; x y) (intersection-sort-set (cdr set1) set2)) (else (intersection-sort-set set1 (cdr set2))))))) 将某个元素加入到集合中 12345(define (adjoin-set x set) (cond ((null? set) (cons x set)) ((equal? x (car set)) set) ((&lt; x (car set)) (cons x set)) (else (cons (car set) (adjoin-set x (cdr set)))))) 求两个集合的并集 12345678(define (union-sort-set set1 set2) (cond ((null? set1) set2) ((null? set2) set1) (else (let ((x (car set1)) (y (car set2))) (cond ((&lt; x y) (cons x (nion-sort-set (cdr set1) set2))) ((&gt; x y) (cons y (union-sort-set set1 (cdr set2)))) (else (cons x (union-sort-set(cdr set1) (cdr set2))))))))) 集合作为有序二叉树 构造函数与选择函数 1234567891011;(dataItem, left-branch, right-branch)(define (entry tree) (car tree))(define (left-branch tree) (cadr tree))(define (right-branch tree) (caddr tree))(define (make-tree entry left-branch right-branch) (list entry left-branch right-branch)) 判断某个元素是否属于某个集合 1234567(define (element-of-set? x set) (if (null? set) #f (let ((dataItem (entry set))) (cond ((= dataItem x) #t) ((&gt; dataItem x) (element-of-set x (left-branch set))) (else (element-of-set x (right-branch set))))))) 求两个集合的交集 12345(define (intersection-set set1 set2) (let ((list1 (tree-&gt;list set1)) (list2 (tree-&gt;list set2))) (let ((res (intersection-sort-set list1 list2))) (list-tree res)))) 求两个集合的并集 1234567891011121314151617181920212223242526272829303132333435; 辅助函数：将树形结构转为列表结构(define (tree-&gt;list tree) (define (copy-to-list tree result-list) (if (null? tree) result-list (copy-to-list (left-branch tree) (cons (entry tree) (copy-to-list (right-branch tree) result-list))))) (copy-to-list tree &apos;()));辅助函数：将列表结构转位树形结构(define (list-tree elements) (car (partial-tree elements (length elements))))(define (partial-tree elts n) (if (= n 0) (cons &apos;() elts) (let ((left-size (quotient (- n 1) 2))) (let ((left-result (partial-tree elts left-size))) (let ((left-tree (car left-result)) (non-left-elts (cdr left-result)) (right-size (- n (+ left-size 1)))) (let ((this-entry (car non-left-elts)) (right-result (partial-tree (cdr non-left-elts) right-size))) (let ((right-tree (car right-result)) (remaining-elts (cdr right-result))) (cons (make-tree this-entry left-tree right-tree) remaining-elts))))))))(define (union-set set1 set2) (let ((list1 (tree-&gt;list set1)) (list2 (tree-&gt;list set2))) (let ((res (union-sort-set list1 list2))) (list-tree res)))) 添加元素到集合 123456789(define (adjoin-set x set) (cond ((null? set) (make-tree x &apos;() &apos;())) ((= x (entry set)) set) ((&lt; x (entry set)) (make-tree (entry set) (adjoin-set x (left-branch set)) (right-branch set))) (else (make-tree (entry set) (left-branch set) (adjoin-set x (right-branch set)))))) 总结 通过三种不同的数据表示集合，分析了程序在使用集合操作，比如检查是否属于集合、集合的交集、集合并集等操作，在时间复杂度上是存在差异的。如下表格： 表示法 检查元素是否属于集合 添加元素 交集 并集 未排序的表 O(n) O(n) O(n^2) O(n^2) 排序的表 O(n) O(n) O(n) O(n) 有序二叉树 O(log n) O(log n) O(n) O(n) 也就是我们常说: 程序=数据结构+算法","comments":true,"tags":[{"name":"sicp","slug":"sicp","permalink":"http://yoursite.com/tags/sicp/"},{"name":"scheme","slug":"scheme","permalink":"http://yoursite.com/tags/scheme/"}]},{"title":"Hello World","date":"2017-07-21T16:00:00.000Z","path":"2017/07/22/hello-world/","text":"大家好： 本文是使用Hexo的第一篇博文，主要是给大家报个到。欢迎来到我的菜园子。","comments":true,"tags":[{"name":"随记","slug":"随记","permalink":"http://yoursite.com/tags/随记/"}]}]