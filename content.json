[{"title":"mock和RAP入门教程","date":"2017-07-30T16:00:00.000Z","path":"2017/07/31/mock-rap-basic-uasge/","text":"在很早以前公司里面就接入了rap在线管理接口文档平台，通过图形化书写接口文档，给前端同事使用。但是之前也仅仅是用于写接口文档，从来没有研究过它还有其他用途。最近与自己合作的一个前端同事说，你为啥不利用好rap来写接口文档，它会自动生成mock数据，我们就不用将rap默认生成的数据修改后，再本地测试一下。弄完之后再与你们联调。今儿就花了2个小时左右研究一下rap，顺藤摸瓜出来mock。下面简单介绍一下，mock以及如何在rap中使用mock，生成比较好的模拟数据，提高前后端协作效率。 mock.js1mock.js随机生成数据，让前端开发人员在开发阶段时独立于后端，使用mockjs可以自测代码。 语法规范 数据模板定义规范(DTD:Data Template Definition) 数据占位符规范(DPD: Data Placeholder definition) 数据模板定义规范格式&#39;name|rule&#39;:value (属性名|生成规则:属性值)，其中生成规则是可选的 生成规则 7种生成规则 &#39;name|min-max&#39;:value &#39;name|count&#39;:value &#39;name|min-max.dmin-dmax&#39;:value &#39;name|+step&#39;:value &#39;name|min-max.dcount&#39;:value &#39;name|count.dmin-dmax&#39;:value &#39;name|count.dcount&#39;:value 生成规则的含义依赖属性值的类型才能确认，这一点特别重要。也是mock的关键所在。比如： &#39;name|min-max&#39;:string: 通过重复[min,max]次string生成新字符串。 &#39;name|min-max&#39;:number: 生成一个number，返回在[min,max]。 属性值 属性值可含@（占位符） 指定最终的值和类型 属性值类型 String Number Boolean Object Array Function RegExp Path 学过js看着十分简单，只是多了RegExp 和 Path，其他简直一模一样。 数据占位符定义规范DPD占位符1.占位符只是在属性字符串中占个位置，并不出现在最终的属性值中2.格式：@占位符或者@占位符(参数[,参数])3.占位符 用@标识后面的字符串是占位符 引用的是Mock.Random中的方法 扩展定义占位符：Mock.Random.extend() 引用数据模板中的属性 支持相对路径和绝对路径 4.数据占位符类型数据占位符一共有如下几种类型： Basic Date Image Color Text Name Web Address Helper Miscellaneous 具体mock语法示例，请参考mock示例2，里面详细的介绍了各个类型使用方法。 rap写接口文档中运用mock3什么是rapRAP是前后端沟通桥梁的通信接口，是一个图形化的接口文档管理的软件。它可以自动生成mock数据，在开发时候前端同事可以不依赖于后端的数据，而是根据mock规则自动生成的模拟数据进行测试。 怎么在rap中是使用mock有很多资料，且是图文并茂写博文4,5。总结起来，在rap中运用mock方法如下： 左边变量写 name|rule，此处相当于就是mock中的&#39;name|rule&#39;; 右边备注写 @mock=value。其语法规则mock一样。1.https://github.com/nuysoft/Mock/wiki ↩2.http://mockjs.com/examples.html ↩3.https://github.com/thx/RAP/wiki/ ↩4.http://www.imooc.com/article/17588 ↩5.http://blog.sina.com.cn/s/blog_c00ccc680102x0ue.html ↩","comments":true,"tags":[{"name":"mock","slug":"mock","permalink":"http://yoursite.com/tags/mock/"},{"name":"RAP","slug":"RAP","permalink":"http://yoursite.com/tags/RAP/"}]},{"title":"python实现http发送POST请求","date":"2017-07-24T16:00:00.000Z","path":"2017/07/25/python-http-post/","text":"现在开发是前后端完全分离的，在公司里面很多接口都和登陆态相关联起来。从而使得我在需求开发的时候依赖于前端同事打包完之后才开始测试自己的需求功能。所以比较耗费时间和精力。但是我们的服务接口是不依赖登陆态的，为了测试自己的服务接口，需要模拟发送HTTP请求，以便后面偷懒。本文就此介绍一下如何解决此问题。 语言选择以及依赖包为了能够快速解决此问题，首先需要找到合适的工具，俗话说，“工欲善其事，必先利其器。”在程序设计中首先就是语言的选择，相比于java，对python更为熟悉一点。说句皮外话，虽然在公司用java开发，但是对java熟悉程度不如python,汗颜啦。回归正题，选好了语言之后，紧接着就是如何模拟发送HTTP请求。google一番找到一个第三方包urllib3。如何安装urllib3以及使用文档教程。 实现现在我们来看看，如何使用urllib3包来模拟发送HTTP的POST请求，请求参数是JSON格式。为了能够使用urllib3模块，需要在使用导入urllib3模块，代码：import urllib3。使用PoolManager实例来发送请求，它已经为我们封装处理好了连接池以及线程安全问题，我们没有必要再次徒手开发一套。其实，urllib3中最为核心关键的方法是request方法，它指定发送请求的方式、请求地址请求的参数。具体步骤如下： 指定请求方法以及url; 将请求的参数编码，然后作为body的值; 设置请求头部的Content-Type为JSON格式. 下面是一个示例代码： 12345678910111213#-*- coding:utf-8 -*-import urllib3from urllib import urlencodeimport jsondef testEsaInterface(url, param): http = urllib3.PoolManager() try: r = http.request('POST',url, body=json.dumps(param).encode('utf-8'),headers=&#123;'Content-Type': 'application/json'&#125;) if r.status == 200: print r.data except urllib3.exceptions.MaxRetryError as e: print repr(e) 如果想对返回的结果进行处理，先将返回的数据进行解码以及反序列化，可以使用decode函数解码，loads函数反序列化。然后采用类似于下标的访问方式获取相关字段的值。示例代码如下： 123res = json.loads(r.data.decode('utf-8'))if (\"906\" == res['data']['returnCode']): # to do something 下图是我测试人脸识别功能一个测试结果： postman发送post请求弄完工具之后，本来想再做一个网页版的，后面发现chrome中有一个插件postman,可以解决我的问题，突然发现重复造轮子咯。下面简单介绍一下，如何用postman发送post请求，其中请求的参数为JSON格式。步骤如下： 选择发送请求的方式为 POST; 输入访问的URL 在headers标签页输入 Content-type, 对应的值为 application/json; 在body标签页面，选择raw,然后在输入JSON格式的请求参数; 最后点击send按钮即可. 是不是发现很简单，如果你觉得还是不清楚,可以参考此博文。 本文仅仅简单介绍了urllib3模块发送HTTP的POST请求方式，还有很多功能需要大家自己去发掘。 参考 安装urllib3: https://pypi.python.org/pypi/urllib3/ urllib3的使用教程: https://urllib3.readthedocs.io/en/latest/user-guide.html postman以JSON格式发送POST请求: http://www.cnblogs.com/shimh/p/6093229.html","comments":true,"tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"},{"name":"http","slug":"http","permalink":"http://yoursite.com/tags/http/"}]},{"title":"Hello World","date":"2017-07-21T16:00:00.000Z","path":"2017/07/22/hello-world/","text":"大家好： 本文是使用Hexo的第一篇博文，主要是给大家报个到。欢迎来到我的菜园子。","comments":true,"tags":[{"name":"随记","slug":"随记","permalink":"http://yoursite.com/tags/随记/"}]},{"title":"sicp 数据对象之集合操作","date":"2017-07-21T16:00:00.000Z","path":"2017/07/22/sicp-dataobject-set/","text":"本文主要介绍不同的数据抽象，对应用程序在使用公共函数时会造成何种影响。这里主要是使用集合使用三种数据来表示：集合作为未排序的表、集合作为排序的表、集合作为有序二叉树，探讨不同的数据对象形式表示集合时，对使用集合的程序性能的影响。 基本概念 选择函数与构造函数 构造函数：说明一个数据对象是由哪些原始组成的。 选择函数：怎么将数据对象中的组成元素抽取出来。 数据抽象定义数据定义就是一组选择函数与构造函数，以及为了使它们成为一套合法的表示。因此它们需要满足一组特定的条件。 看着上面两个定义是不是很拗口，不知道在说啥。举个例子来说，如果一个有理数p是由整数 n 和 整数 d 构造而成。也就是 p = n /d。 12345;构造函数 p = n / dp = (make-rat n d);选择函数n = (numer p)d = (denom p) 集合操作在高中的数学我们学习过，集合表示一组无重复的元素聚集而成。在数据结构中，集合表示一组具有相同属性的元素，并且满足数学中的集合属性：无序性。 常见集合的操作，判断某个元素是否属于某个集合、求两个集合的交集、求两个集合的并集。假设集合A={1,2,3}、B={2,3,4}，以及元素m=2,n=5，则： 判断某个元素是否属于某个集合：m 属于A,也属于B，而n不属于A,也不属于B; A 与 B 的交集为：{2, 3}; A 与 B 的并集为：{1, 2, 3, 4}下面我们来看看使用三种不同的数据表示，会对写集合常见操作造成什么样影响。集合作为未排序的表构造函数与选择函数直接使用list 函数，但是集合中元素是排序的，比如集合A={1, 10, 2, 4, 3}。 判断某个元素是否属于某个集合1234(define (element-of-set? x set) (cond ((null? set) #f) (else (or (equal? x (car set)) (element-of-set? x (cdr set)))))) 求两个集合的交集12345(define (intersection-set set1 set2) (cond ((or (null? set1) (null? set2)) &apos;()) ((element-of-set? (car set1) set2) (cons (car set1) (intersection-set (cdr set1) set2))) (else (intersection-set (cdr set1) set2)))) 求两个集合的并集123456(define (union-set set1 set2) (cond ((null? set1) set2) ((null? set2) set1) ((element-of-set? (car set1) set2) (union-set (cdr set1) set2)) (else (cons (car set1) (union-set (cdr set1) set2))))) 将某个元素加入集合中1234(define (adjion-set x set) (if (element-of-set? x set) set (cons x set))) 集合作为排序的表构造函数与选择函数直接使用list 函数，但是集合中元素是排序的，比如集合A={1, 2, 3, 4, 5, 10}。 判断某个元素是否属于某个集合12345(define (element-of-set? x set) (cond ((null? set) #f) ((equal? x (car set)) #t) ((&lt; x (car set)) #f) (else (element-of-set? x (cdr set))))) 求两个集合的交集12345678(define (intersection-sort-set set1 set2) (if (or (null? set1) (null? set2)) &apos;() (let ((x (car set1)) (y (car set2))) (cond ((= x y) (cons x (ntersection-sort-set (cdr set1) (cdr set2)))) ((&lt; x y) (intersection-sort-set (cdr set1) set2)) (else (intersection-sort-set set1 (cdr set2))))))) 将某个元素加入到集合中12345(define (adjoin-set x set) (cond ((null? set) (cons x set)) ((equal? x (car set)) set) ((&lt; x (car set)) (cons x set)) (else (cons (car set) (adjoin-set x (cdr set)))))) 求两个集合的并集12345678(define (union-sort-set set1 set2) (cond ((null? set1) set2) ((null? set2) set1) (else (let ((x (car set1)) (y (car set2))) (cond ((&lt; x y) (cons x (nion-sort-set (cdr set1) set2))) ((&gt; x y) (cons y (union-sort-set set1 (cdr set2)))) (else (cons x (union-sort-set(cdr set1) (cdr set2))))))))) 集合作为有序二叉树构造函数与选择函数1234567891011;(dataItem, left-branch, right-branch)(define (entry tree) (car tree))(define (left-branch tree) (cadr tree))(define (right-branch tree) (caddr tree))(define (make-tree entry left-branch right-branch) (list entry left-branch right-branch)) 判断某个元素是否属于某个集合1234567(define (element-of-set? x set) (if (null? set) #f (let ((dataItem (entry set))) (cond ((= dataItem x) #t) ((&gt; dataItem x) (element-of-set x (left-branch set))) (else (element-of-set x (right-branch set))))))) 求两个集合的交集12345(define (intersection-set set1 set2) (let ((list1 (tree-&gt;list set1)) (list2 (tree-&gt;list set2))) (let ((res (intersection-sort-set list1 list2))) (list-tree res)))) 求两个集合的并集1234567891011121314151617181920212223242526272829303132333435; 辅助函数：将树形结构转为列表结构(define (tree-&gt;list tree) (define (copy-to-list tree result-list) (if (null? tree) result-list (copy-to-list (left-branch tree) (cons (entry tree) (copy-to-list (right-branch tree) result-list))))) (copy-to-list tree &apos;()));辅助函数：将列表结构转位树形结构(define (list-tree elements) (car (partial-tree elements (length elements))))(define (partial-tree elts n) (if (= n 0) (cons &apos;() elts) (let ((left-size (quotient (- n 1) 2))) (let ((left-result (partial-tree elts left-size))) (let ((left-tree (car left-result)) (non-left-elts (cdr left-result)) (right-size (- n (+ left-size 1)))) (let ((this-entry (car non-left-elts)) (right-result (partial-tree (cdr non-left-elts) right-size))) (let ((right-tree (car right-result)) (remaining-elts (cdr right-result))) (cons (make-tree this-entry left-tree right-tree) remaining-elts))))))))(define (union-set set1 set2) (let ((list1 (tree-&gt;list set1)) (list2 (tree-&gt;list set2))) (let ((res (union-sort-set list1 list2))) (list-tree res)))) 添加元素到集合123456789(define (adjoin-set x set) (cond ((null? set) (make-tree x &apos;() &apos;())) ((= x (entry set)) set) ((&lt; x (entry set)) (make-tree (entry set) (adjoin-set x (left-branch set)) (right-branch set))) (else (make-tree (entry set) (left-branch set) (adjoin-set x (right-branch set)))))) 总结通过三种不同的数据表示集合，分析了程序在使用集合操作，比如检查是否属于集合、集合的交集、集合并集等操作，在时间复杂度上是存在差异的。如下表格： 表示法 检查元素是否属于集合 添加元素 交集 并集 未排序的表 O(n) O(n) O(n^2) O(n^2) 排序的表 O(n) O(n) O(n) O(n) 有序二叉树 O(log n) O(log n) O(n) O(n) 也就是我们常说: 程序=数据结构+算法","comments":true,"tags":[{"name":"sicp","slug":"sicp","permalink":"http://yoursite.com/tags/sicp/"},{"name":"scheme","slug":"scheme","permalink":"http://yoursite.com/tags/scheme/"}]}]