[{"title":"SLF4J 和 LOG4J","date":"2018-07-06T16:00:00.000Z","path":"2018/07/07/arts/tip/T-slf4jandlog4j/","text":"¶\b折腾背景 在公司开发都是使用内部框架的，使用打印日志没怎么关注过。本周在学习Srping的时候采用SLF4J和LOG4J打印日志。分享一下遇到的小问题以及解决方法。 ¶SLF4J是啥 SLF4J是 Simple Logging Facade for Java简称，是为日志框架（比如，java.util.logging, logback 和 log4j）提供接口服务，具体日志打印是怎么实现有日志框架决定的。 ¶小实验 下载SLF4J相关的JAR,引入到lass path。然后运行下面小程序: 123456789import org.slf4j.Logger;import org.slf4j.LoggerFactory;public class HelloWorld &#123; public static void main(String[] args) &#123; Logger logger = LoggerFactory.getLogger(HelloWorld.class); logger.info(\"Hello World\"); &#125;&#125; 会报如下错误: SLF4J: Failed to load class “org.slf4j.impl.StaticLoggerBinder”. SLF4J: Defaulting to no-operation (NOP) logger implementation SLF4J: See http://www.slf4j.org/codes.html#StaticLoggerBinder for further details. 不要担心，到这里说明你向前走了一步，把 slf4j-simple-1.8.0-beta2.jar,在运行一下就出现，你想要的结果了。 [main] INFO HelloWorld - Hello World ¶使用LOG4J 后面想打印Debug级别的日志，所以下载log4j的JAR包。下载后把其加入class path , 然后执行下面这个测试程序： 12345678910111213141516import org.slf4j.Logger;import org.slf4j.LoggerFactory;public class Wombat &#123; final Logger logger = LoggerFactory.getLogger(Wombat.class); Integer t; Integer oldT; public void setTemperature(Integer temperature) &#123; oldT = t; t = temperature; logger.debug(\"Temperature set to &#123;&#125;. Old temperature was &#123;&#125;.\", t, oldT); if(temperature.intValue() &gt; 50) &#123; logger.info(\"Temperature has risen above 50 degrees.\"); &#125; &#125; &#125; 输入 temperature 大于50则有日志，否则什么也没有。 Temperature has risen above 50 degrees. 然后把slf4j-log4j加入class path 下运行就报如下错误： SLF4J: Class path contains multiple SLF4J bindings. SLF4J: Found binding in [jar:file:/D:/tools/extraLib/log/slf4j-log4j12-1.7.25.jar!/org/slf4j/impl/StaticLoggerBinder.class] SLF4J: Found binding in [jar:file:/D:/tools/extraLib/log/slf4j-simple-1.7.25.jar!/org/slf4j/impl/StaticLoggerBinder.class] SLF4J: See http://www.slf4j.org/codes.html#multiple_bindings for an explanation. 先把slf4j-simple-1.8.0-beta2.jar移除，然后在src目前下新建log4j.properties，并敲入如下内容，用于配置log4j.properties和设置debug级别。 12345log4j.rootLogger=DEBUG, stdoutlog4j.appender.stdout=org.apache.log4j.ConsoleAppender log4j.appender.stdout.layout=org.apache.log4j.PatternLayout log4j.appender.stdout.layout.ConversionPattern=%c&#123;1&#125; - %m%n 最后运行，运行结果如下： Wombat - Temperature set to 20. Old temperature was null. Wombat - Temperature set to 60. Old temperature was 20. Wombat - Temperature has risen above 50 degrees. 为什么遇到上面两个问题，看到手册后面的文档说明就会明白,也是我们注意的地方。现摘录如下： To switch logging frameworks, just replace slf4j bindings on your class path. For example, to switch from java.util.logging to log4j, just replace slf4j-jdk14-1.8.0-beta2.jar with slf4j-log4j12-1.8.0-beta2.jar. SLF4J does not rely on any special class loader machinery. In fact, each SLF4J binding is hardwired at compile time to use one and only one specific logging framework. For example, the slf4j-log4j12-1.8.0-beta2.jar binding is bound at compile time to use log4j. In your code, in addition to slf4j-api-1.8.0-beta2.jar, you simply drop one and only one binding of your choice onto the appropriate class path location. Do not place more than one binding on your class path. 特别是下面张图，就会明了SLF4J的是干嘛的了，解决了啥问题。 ¶小思考 阅读了一下manual，以及捣鼓了一下两个示例，对SLF4J有点小想法如下： SLF4J易于维护和升级 SLF4J是一个日志API，具体日志怎么整的是日志框架的事情，将日志与日志框架解耦，也即是后面如果项目需要升级比如将 LOG4J到LogBack。 高效且易于阅读 现在组里面都是使用+拼接打印的日志的，而SLF4J中可以使用占位符{},比如第二个例子就是。","comments":true,"tags":[{"name":"tip","slug":"tip","permalink":"http://yoursite.com/tags/tip/"},{"name":"slf4j","slug":"slf4j","permalink":"http://yoursite.com/tags/slf4j/"},{"name":"log4j","slug":"log4j","permalink":"http://yoursite.com/tags/log4j/"}]},{"title":"ARTS-7月1周","date":"2018-07-06T16:00:00.000Z","path":"2018/07/07/arts/7m1w-summary/","text":"¶7月1周ARTS总结 希望自己继续保持下去，分享第三个ARTS的内容： 1.A：来源是leetcode在做了一个难点的算法题目Remove Duplicates from Sorted Array，利用排序数组的特性以及“双指针”思想解决之。 2.R：分享一下本周看的英文文章:How you can improve your workflow using the JavaScript consolen，是关于JavaScript中console函数的技巧。 3.T: 分享slf4和log4j入门。 4.S: 分享grep和less命令乱码。","comments":true,"tags":[{"name":"ARTS","slug":"ARTS","permalink":"http://yoursite.com/tags/ARTS/"}]},{"title":"Algorithm:Remove Duplicates from Sorted Array","date":"2018-07-06T16:00:00.000Z","path":"2018/07/07/arts/algorithm/A-Remove-Duplicates-from-Sorted-Array/","text":"¶问题 Given a sorted array nums, remove the duplicates in-place such that each element appear only once and return the new length. Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory. ¶Example 1: Given nums = [1,1,2], Your function should return length = 2, with the first two elements of nums being 1 and 2 respectively. It doesn’t matter what you leave beyond the returned length. ¶Example 2: Given nums = [0,0,1,1,1,2,2,3,3,4], Your function should return length = 5, with the first five elements of nums being modified to 0, 1, 2, 3, and 4 respectively. It doesn’t matter what values are set beyond the returned length. Level: Hard ¶解题思路 如果没有\bO(1)的空间复杂度，并且不关注修改后原来数组的结果。我们可以利用\bset\b或者map来解决此题。\b\b现在题目既然要求O(1)的\b空间复杂度解决，那么\b可以使用\b“双指针”的思路和排序数组的特性来解决此题,具体思路如下： 设pos为新数组下标值，初始化为0；\bidx为\b原数组的下标，\b[1, n); 若arr[pos] != arr[i],则 \barr[pos++] = arr[i] \b重复2，直到 i = n; 返回 新数组的长度：pos+1 \b详细代码如下： 12345678910111213public int removeDuplicates(int[] nums) &#123; if (null == nums || nums.length &lt;= 0) &#123; return 0; &#125; int len = nums.length; int pos = 0; for (int idx = 1; idx &lt; len; ++idx) &#123; if (nums[pos] != nums[idx]) &#123; nums[++pos] = nums[idx]; &#125; &#125; return pos + 1;&#125; 时间复杂度为O(n),其中n为排序数组的长度； 空间复杂度为O(1)","comments":true,"tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://yoursite.com/tags/algorithm/"},{"name":"array","slug":"array","permalink":"http://yoursite.com/tags/array/"}]},{"title":"Share：grep命令查日志和日志内容乱码","date":"2018-07-06T16:00:00.000Z","path":"2018/07/07/arts/share/S-grep/","text":"¶grep命令查日志 本周突然接到通知，开发同事需要周六日轮流值班处理生产问题。本周六我做了支持。 查询日志的时候，使用最多的就是grep命令。周六碰到一个客户不能提前还款。 使用如下参数查找： 查询 关键字词 匹配所在的行：grep -n '关键字词' 文件 查询关键字词 前面或者后面多少行，grep -Anum1 -Bnum2 关键字词 文件 ¶日志内容乱码 问题描述：使用grep找出的部分日志没有乱码，中文显示好的。而使用less命令 发现乱码，后面使用export LANG=zh_CN.UTF8;，仍旧没有解决问题。 最后使用export LESSCHARSET=latin1,解决乱码问题。可以参考less - Unix, Linux Command","comments":true,"tags":[{"name":"share","slug":"share","permalink":"http://yoursite.com/tags/share/"},{"name":"grep","slug":"grep","permalink":"http://yoursite.com/tags/grep/"}]},{"title":"Review《How you can improve your workflow using the JavaScript console》","date":"2018-07-06T16:00:00.000Z","path":"2018/07/07/arts/review/R-using-js-console/","text":"¶概述 本周分享review的文章是JavaScript中Console函数的使用，觉得很棒所以将其整理出来分享给大家。 ¶Console的作用 JS中的console是每个浏览器必备的一个特性。它允许开发者： View a log of errors and warnings that occur on a web page. 查看出现在web页面中错误和警告 Interact with the web page using JavaScript commands. 使用JS命令与web页面进行交互 Debug applications and traverse the DOM directly in the browser 直接绕过DOM调试应用 Inspect and analyze network activity 监测和分析网络活动 ¶调试类 使用如下函数，可以传入多个参数，它们会自动拼接，并以空格分隔，最终显示要查看的内容。 Console.log Console.error Console.warn Console.info 示例： 1234const niceJson = &#123;a:1, b:2, c:3&#125;;console.log(\"log\", niceJson, new Date());console.warn(\"warn\", niceJson, new Date());console.info(\"info\", niceJson, new Date()); ¶归类 使用console.group把log（或者info或者warn)归为一起。 示例： 12345678910111213function doSomething(obj) &#123; console.group('doSomething Profile'); const _data = new Date(); console.log('evauating data:', _data); const _fullName = `$&#123;obj.firstName&#125; $&#123;obj.lastName&#125;` console.log('fullName:', _fullName); const _id = Math.random(1); console.log('id:', _id); console.groupEnd();&#125;doSomething(&#123;\"firstName\":\"yun\", \"lastName\":\"feng\"&#125;); doSomething Profile evauating data: Sun Jul 08 2018 15:46:11 GMT+0800 (China Standard Time) fullName: yun feng id: 0.26763583139597613 ¶数据表格化 可以使用console.table将对象或者对象数组表格化。 示例： 1234567const typeOfConsole = [ &#123;name:'log', type:'standard'&#125;, &#123;name:'info', type:'standard'&#125;, &#123;name:'table', type:'wow'&#125;];console.table(typeOfConsole); 结果： (index) name type 0 “log” “standard” 1 “info” “standard” 2 “table” “wow” 示例2： 123456789const mySocial = &#123; facebook:true, linkedin:false, flickr:false, instagram:true, Vkontaktebadoo:false&#125;;console.table(mySocial); (index) Value facebook true linkedin false flickr false instagram true Vkontaktebadoo false ¶统计类 测试函数的运行时间或者统计某一行代码执行的总数。 console.count console.time console.timeEnd 示例： 1234567891011console.time('total');console.time('init arr');const arr = new Array(20);console.timeEnd('init arr');for (var i = 0; i &lt; arr.length; ++i) &#123; arr[i] = new Object(); const _type = (i % 2 === 0) ? 'even' : 'odd'; console.count(_type + \" added\");&#125;console.timeEnd('total'); 结果： init arr: 0.003662109375ms even added: 1 odd added: 1 even added: 2 odd added: 2 even added: 3 odd added: 3 even added: 4 odd added: 4 even added: 5 odd added: 5 even added: 6 odd added: 6 even added: 7 odd added: 7 even added: 8 odd added: 8 even added: 9 odd added: 9 even added: 10 odd added: 10 total: 2.650146484375ms ¶堆栈跟踪类 console.trace console.assert 示例： 12345678910111213function lesserThan(a, b) &#123; console.assert(a &lt; b, &#123;\"message\":\"a is not lesser than b\", \"a\":a, \"b:\":b&#125;);&#125;lesserThan(6, 5);console.trace(\"End\");// resultVM634:2 Assertion failed: &#123;message: \"a is not lesser than b\", a: 6, b:: 5&#125;lesserThan @ VM634:2(anonymous) @ VM634:5VM634:6 End(anonymous) @ VM634:6 ¶清除console 使用uglifyjs-webpack-plugin清除所有的console。 123456789101112131415161718192021const UglifyJsPlugin = require('uglify-webpack-plugin')var debug = process.env.NODE_ENV !== 'production'// ...optimization:&#123; minimizer:!debug ? [ new UglifyJsPlugin(&#123; // compression specific options uglifyOption: &#123; // Eliminate comments comments:false, compress: &#123; // removing warnings warnings:false, // drop console statements drop_console: true &#125;, &#125; &#125;)] :[]&#125; ¶总结 毕竟使用console是用来调试代码的，不能让这些代码上生产版本，所以需要注意之处。另外，就是在十分明确的地方就没有必要使用console,以免滥用误用。","comments":true,"tags":[{"name":"review","slug":"review","permalink":"http://yoursite.com/tags/review/"},{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"}]},{"title":"Junit测试Java多线程小疑","date":"2018-06-28T16:00:00.000Z","path":"2018/06/29/arts/tip/T-java-thread-unit/","text":"¶遇到背景 本周分享一个小问题，在看TIJ（Java编程思想）中多线程机制一节时，把书中的示例使用Junit来测试。发 现与书中使用main方法来测试的结果是不一样的。 ¶问题描述 为了描述问题，先引用书中的例子：定义一个简单地任务，代码如下： 123456789101112131415161718192021public class LiftOff implements Runnable &#123; protected int countDown = 10; private static int taskCount = 0; private final int id = taskCount++; public LiftOff() &#123;&#125; public LiftOff(int countDown) &#123; this.countDown = countDown; &#125; public String status() &#123; return \"#\" + id + \"(\" + (countDown &gt; 0 ? countDown : \"liftoff!\") + \"),\"; &#125; @Override public void run() &#123; while (countDown-- &gt; 0) &#123; System.out.println(status()); Thread.yield(); &#125; &#125; &#125; 使用Junit测试代码如下： 123456789@Testpublic void testMoreBasicThread() throws InterruptedException &#123; for (int i = 0; i &lt; 5; ++i) &#123; Thread t = new Thread(new LiftOff()); //t.join(); t.start(); &#125; System.out.println(\"Waiting for LiftOff\");&#125; 使用main测试的结果与Junit测试的结果相比对，就会发现两者不同。 main函数测试的结果 Waiting for LiftOff#0(9),#0(8),#0(7),#0(6),#0(5),#0(4),#0(3),#0(2),#0(1),#0(liftoff!), Junit测试的结果 Waiting for LiftOff#0(9),#0(8),#0(7),#0(6),#0(5),#0(4),#0(3),#0(2), 为什么使用Junit输出的结果会比使用main方法直接测试的要少。 ¶分析与解决 一般情况下，只有当所有的守护线程完结之后JVM才会结束。为此，你可以在执行任务的线程上调用 t.setDaemon(false)来防止JVM在任务未执行完成之前就结束生命了。但是Junit会在主线程结束时调用 System.exit()。具体的见JunitCore.java中代码，下面是与此问题相关的代码1。解决方法就是在 调用t.start()之前调用t.jion(),让Junit线程等待任务的完成2。 123public static Result runClasses(Class&lt;?&gt;... classes) &#123; return runClasses(defaultComputer(), classes);&#125; ¶参考资料 1.https://github.com/junit-team/junit4/blob/master/src/main/java/org/junit/runner/JUnitCore.java#L48 ↩2.https://stackoverflow.com/questions/16616590/thread-behaving-strangely-in-junit ↩","comments":true,"tags":[{"name":"junit","slug":"junit","permalink":"http://yoursite.com/tags/junit/"},{"name":"thread","slug":"thread","permalink":"http://yoursite.com/tags/thread/"},{"name":"tip","slug":"tip","permalink":"http://yoursite.com/tags/tip/"}]},{"title":"ARTS-6月4周","date":"2018-06-28T16:00:00.000Z","path":"2018/06/29/arts/6m4w-summary/","text":"¶本周ARTS总结 6月最后一周的ARTS一直没有写完，主要原因有两点： 算法题目一直没有想到一个很好的想法解决； 这周家里和工作上都有很多事情，只能零碎的写写； 希望自己继续保持下去，分享第二个ARTS的内容： leetcode在做了一个难点的算法题目Median of Two Sorted Arrays，使用归并排序的算法解决之，但不是最好的，到目前还没有想到到最优解。 分享一下本周看的英文文章，主要是Peter Noring 和 Alan Skorkin的文章，主要是关于学习态度的问题，然后分享跟着MDN Web教程修改程序做成mntfun的介绍页面； 分享本周使用Junit测试多线程代码时，发现的一个小问题; 分享一下最近对TDD使用的一些小想法。","comments":true,"tags":[{"name":"ARTS","slug":"ARTS","permalink":"http://yoursite.com/tags/ARTS/"}]},{"title":"Algorithm:Median of Two Sorted Arrays","date":"2018-06-28T16:00:00.000Z","path":"2018/06/29/arts/algorithm/A-Find-median/","text":"¶问题描述 There are two sorted arrays nums1 and nums2 of size m and n respectively. Find the median of the two sorted arrays. The overall run time complexity should be O(log(m+n)). Example 1: nums1 = [1, 3] nums2 = [2] The median is 2.0 Example 2: nums1 = [1, 2] nums2 = [3, 4] The median is (2 + 3)/2 = 2.5 Level: Hard ¶解题思路与状态 ¶问题分析 已知条件 两个排序数组，数组num1，元素个数为m；数组num2，元素个数为n； 问题 找到num1和num2的中位数 约束 算法的运行最坏时间为 O(log(m+n)) ¶解题思路 ¶归并排序法 如果没有时间约束，就可以使用归并排序，若排序后的结果为nums3,元素个数为k=m+n;最终将问题转化为： 求数组nums3的中位数。 若k为奇数，直接为nums3[k/2]; 若k为偶数，则为(nums3[k/2]+nums3[k/2-1])/2； 此解法的时间复杂度为O(m+n),主要是归并排序上；空间复杂度为O(m+n)，用于暂存归并排序后的结果。 具体的代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445// find the median of a sorted arrrayprivate double findMedianSortedSignleArray(int[] nums) &#123; if (null == nums || 0 == nums.length) &#123; throw new IllegalArgumentException(\"sorted arrays are illegal.\"); &#125; int len = nums.length; if (0 == len % 2) &#123; return (nums[len/2] + nums[len/2 - 1]) / 2.0; &#125; return nums[len/2];&#125;public double findMedianSortedArrays(int[] nums1, int[] nums2) &#123; if (null == nums1 || 0 == nums1.length) &#123; return findMedianSortedSignleArray(nums2); &#125; if (null == nums2 || 0 == nums2.length) &#123; return findMedianSortedSignleArray(nums1); &#125; // using merge sort int n = nums1.length; int m = nums2.length; int[] mergeNum = new int[n + m]; int i = 0; int j = 0; int k = 0; while (i &lt; n &amp; j &lt; m) &#123; if (nums1[i] &gt; nums2[j]) &#123; mergeNum[k++] = nums2[j++]; &#125; else &#123; mergeNum[k++] = nums1[i++]; &#125; &#125; while (i &lt; n) &#123; mergeNum[k++] = nums1[i++]; &#125; while (j &lt; m) &#123; mergeNum[k++] = nums2[j++]; &#125; return findMedianSortedSignleArray(mergeNum);&#125; ¶递归算法 目前递归算法还未写出来，断断续续思考使用递归的想法有几天了，一直未果。现在留着不写，后续解决 之后在补上。 ¶总结 对于使用递归算法解决此问题没能解决，内心是十分痛苦的。目前的思路是能否借助于二分查找算法解决， 最为关键的是递归结束的条件是什么。","comments":true,"tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://yoursite.com/tags/algorithm/"},{"name":"array","slug":"array","permalink":"http://yoursite.com/tags/array/"}]},{"title":"脚踏实地学习","date":"2018-06-28T16:00:00.000Z","path":"2018/06/29/arts/review/R-learn-by-hard-way/","text":"¶概述 本周阅读了Peter Norving 写的一篇文章《Teach Yourself Programming in Ten Years》1 和 Alan Sorkin 写的一篇文章《The Greatest Developer Fallacy Or The Wisest Words You’ll Ever Hear?》2 。这两篇文章给我的感触比较深，所以本周就分享一下文章大概内容以及本周根据 MDN一步一步做的一个mntfun静态页面。 ¶态度：无捷径可走 主要讲我们学习编程所需要的态度不要企图一蹴而就，也不要好高骛远，没有捷径可走。 刻意练习 The key is deliberative practice: not just doing it again and again, but challenging yourself with a task that is just beyond your current ability, trying it, analyzing your performance while and after doing it, and correcting any mistakes. Then repeat. And repeat again. ** There appear to be no real shortcuts **: even Mozart, who was a musical prodigy at age 4, took 13 more years before he began to produce world-class music. In another genre, the Beatles seemed to burst onto the scene with a string of #1 hits and an appearance on the Ed Sullivan show in 1964. But they had been playing small clubs in Liverpool and Hamburg since 1957, and while they had mass appeal early on, their first great critical success, Sgt. Peppers, was released in 1967. 不要相信：用到的时候再学习，注意平时的积累； 两篇文章都提到要与高手一起合作，沟通； 保持激情 Maybe it is just that people don’t know how to build expertise (there is an element of truth to this), but I have a sneaking suspicion that it’s more about lack of desire rather than lack of knowledge. ¶成为程序员的步骤 我是一个初学者，没有啥资格说如何成为一个程序员，一个好的程序员，直接引用 Pert Noring的经验。如下： Get interested in programming, and do some because it is fun. Program. The best kind of learning is learning by doing. Talk with other programmers; read other programs. If you want, put in four years at a college (or more at a graduate school). Work on projects with other programmers. Learn at least a half dozen programming languages. Remember that there is a “computer” in “computer science”. Get involved in a language standardization effort. Have the good sense to get off the language standardization effort as quickly as possible. ¶分享mntfun介绍网页 本周业余时间跟着MDN开发网站3，学习web开发，主要是跟着入门教程，然后改写成mntfun一个介绍网 站。如下图，比较简陋。 ¶参考资料 1.https://www.skorks.com/2011/02/the-greatest-developer-fallacy-or-the-wisest-words-youll-ever-hear/ ↩2.https://www.skorks.com/2011/02/the-greatest-developer-fallacy-or-the-wisest-words-youll-ever-hear/ ↩3.https://developer.mozilla.org/en-US/docs/Learn/Getting_started_with_the_web ↩","comments":true,"tags":[{"name":"learning","slug":"learning","permalink":"http://yoursite.com/tags/learning/"},{"name":"review","slug":"review","permalink":"http://yoursite.com/tags/review/"}]},{"title":"测试驱动开发小思考","date":"2018-06-28T16:00:00.000Z","path":"2018/06/29/arts/share/S-TDD-is-perfect/","text":"¶TDD疑问 最近学习TDD开发，用在平时开发的时候，就会发现TDD并不完美，特别是测试先行和各种需要覆盖 的测试。存在疑问如下： 是否真的需要一开始就写测试，然后一步一步驱动去开发呢； 后续测试用例的维护，特别与关联其他部门的接口，各种mock和stub； 耗费的时候比先写好代码再测试更大； ¶一些观点 对TDD有一些不成熟的想法，不一定非等需要严格按照TDD开发流程进行项目开发，找到适合自己的就行。TDD 对我来说很难掌握，但可以从TDD中学习和借鉴的是： 开发自己列好测试清单，以便我们单元测试做得足够； 重构自己写的代码； 后面在StackoverFlow上看到一个帖子How deep are your unit tests?，附上问题和比较喜欢的答案： 问题 The thing I’ve found about TDD is that its takes time to get your tests set up and being naturally lazy I always want to write as little code as possible. The first thing I seem do is test my constructor has set all the properties but is this overkill? My question is to what level of granularity do you write you unit tests at? …and is there a case of testing too much? 比较喜欢的两个回答： TDD创始人Kent Beck回答： I get paid for code that works, not for tests, so my philosophy is to test as little as possible to reach a given level of confidence (I suspect this level of confidence is high compared to industry standards, but that could just be hubris). If I don’t typically make a kind of mistake (like setting the wrong variables in a constructor), I don’t test for it. I do tend to make sense of test errors, so I’m extra careful when I have logic with complicated conditionals. When coding on a team, I modify my strategy to carefully test code that we, collectively, tend to get wrong. Different people will have different testing strategies based on this philosophy, but that seems reasonable to me given the immature state of understanding of how tests can best fit into the inner loop of coding. Ten or twenty years from now we’ll likely have a more universal theory of which tests to write, which tests not to write, and how to tell the difference. In the meantime, experimentation seems in order. kitofr的回答 Everything should be made as simple as possible, but not simpler. - A. Einstein One of the most misunderstood things about TDD is the first word in it. Test. That’s why BDD came along. Because people didn’t really understand that the first D was the important one, namely Driven. We all tend to think a little bit to much about the Testing, and a little bit to little about the driving of design. And I guess that this is a vague answer to your question, but you should probably consider how to drive your code, instead of what you actually are testing; that is something a Coverage-tool can help you with. Design is a quite bigger and more problematic issue. 后来看到耗子叔写了一篇TDD并不是看上去的那么美,比我写的好，思考的深。 另外关于Unit test VS TDD讨论也是十分精彩的，推荐阅读。","comments":true,"tags":[{"name":"TDD","slug":"TDD","permalink":"http://yoursite.com/tags/TDD/"},{"name":"share","slug":"share","permalink":"http://yoursite.com/tags/share/"}]},{"title":"ARTS之旅","date":"2018-06-22T16:00:00.000Z","path":"2018/06/23/arts/6m3w-summary/","text":"¶本周ARTS总结 ARTS是左耳朵耗子发起的一个活动，具体如下： Algorithm：每周至少做一个leetcode的算法题; Review：阅读并点评至少一篇英文技术文章； Tip/Techni：学习至少一个技术技巧； Share：分享一篇有观点和思考的技术文章； 你需要坚持至少一年！ 在微信群里面看到此活动的时候，晚上还失眠了，回想自己读书以及工作一年，没有什么习惯坚持下来， 都是两天打鱼三天晒网。现在一直都生活在舒适区或着看了比较多材料也没有什么输出，内心忒崩溃， 越想越烦躁，最后失眠了,后面想将ARTS作为自己的一个项目去维护，既然遇到左耳朵耗子哥，有契机， 就好好把握，也想看看自己能走多远，也希望藉此机会好好锻炼自己。想那么多，又不能改变啥，去做就是。 我自己理解的ARTS目的 A:我学习比较浮躁，夯实以前看算法书，锻炼一下自己的思维能力； R:督促自己学习英语，去总结和思考； T:不要放弃技术，相信技术，积累； S:学会分享，与人沟通，而不是一个人独自学习； 总之，积少成多，说了这么多，该谈谈本周开启ARTS之旅，分享的内容如下： leetcode在做了一个简单地算法题目Two Sum，给定一个数组和一个值，找出两个值之和等于给定的值； 分享一下本周看的英文文章，主要是多兴趣以及一周5小时法则； 分享本周遇到一个简单线上bug以及处理流程; 本周学习TDD开发，分享一下阅读测试驱动开发笔记一; ARTS活动内容来源：左耳朵耗子 20180615 发得的微博。","comments":true,"tags":[{"name":"ARTS","slug":"ARTS","permalink":"http://yoursite.com/tags/ARTS/"}]},{"title":"Review:多兴趣成功以及5小时法则","date":"2018-06-22T16:00:00.000Z","path":"2018/06/23/arts/review/R-mutil-interests/","text":"¶概述 本周阅读了多兴趣与成功以及5小时法则，将其中要点以及自己的感悟分享给大家。 ¶多兴趣与成功 《People Who Have “Too Many Interests” Are More Likely To Be Successful According To Research》一文表明的观点是在现在或者未来，通才更容易成功。读完之后有如下感触： 多视角看问题，更容易解决复杂问题； 保持好奇心，心态要开放不要鄙视或者轻视任何新事物； 学习的东西必须用起来； 读完此文还有吴军老师的《见识》中关于跨界的介绍。加上自己这几年读书和近一年的工作经历，这也想学习， 那也想学习，但是啥没有深入进去。都是学了点皮毛。就如同猴子摘棒子一般。培养的兴趣要为某个核心领域 服务，能够将兴趣结合在一起才行。所以给我自己的告诫： 不要过多兴趣，除非那些天赋和精力超级旺盛的人； 读书或者做事情一定要持续投入； ¶5小时法则 5小时法则的来源是富兰克林，他每日都抽取至少1小时投入学习，每周5个小时。作者也列举了很多例子： Warren Buffett spends five or six hours per day reading five newspapers and 500 pages of corperate reports. Bill Gates reads 50 books per year. Mark Cuban read more than 3 hours every day. Mark Zuckerberg reads at least one book two weeks. … 作者建议如下： Reading：每日不断阅读； Refection： 反思所学以及自己的行为； Experimentation: 解决遇到的问题，利用你学到知识。 Don’t be lazy. Don’t make excuses. Just get it done. ¶参考资料 Why Constant Learners All Embrace the 5-Hour Rule Bill Gates, Warren Buffett And Oprah All Use The 5-Hour Rule 5-Hour Rule: If you’re not spending 5 hours per week learning, you’re being irresponsible People Who Have “Too Many Interests” Are More Likely To Be Successful According To Research 吴军 《见识》关于跨界的介绍","comments":true,"tags":[{"name":"review","slug":"review","permalink":"http://yoursite.com/tags/review/"},{"name":"5小时法则","slug":"5小时法则","permalink":"http://yoursite.com/tags/5小时法则/"},{"name":"兴趣","slug":"兴趣","permalink":"http://yoursite.com/tags/兴趣/"}]},{"title":"Algorithm:Two Sum","date":"2018-06-22T16:00:00.000Z","path":"2018/06/23/arts/algorithm/A-TwoSum/","text":"¶问题描述 Given an array of integers, return indices of the two numbers such that they add up to a specific target.You may assume that each input would have ** exactly one solution**, and you may not use the same element twice. Example Given nums = [2, 7, 11, 15], target = 9, Because nums[0] + nums[1] = 2 + 7 = 9, return [0, 1]. ¶解题思路与状态 当时看完题目给自己定了一个30分钟的闹钟，可以在这段时间中搞定它。存在疑问： 若数组排序，可以使用两边夹方法解决之；若不是怎么处理。 数组中是否存在重复元素，若有怎么处理。 未找到满足条件的元素，是抛出异常还是给定特殊的标志，比如[-1,-1]。 看完题目之后头脑中形成的解题思路暴力破解法，一下搞完，本地测试通过了，时间复杂度为 O(n^2)。 不是自己想要的结果，接着想能都把元素的值与下标对应起来，然后再去查找，利用空间换时间，以缩短查询 时间。后面出现了使用hashmap做处理的元素值，这种情况在数组中存在重复元素有问题。后面想了很久 仍旧没有想到使用一个hashmap来解决此问题。这个时候已经过去40分钟，心里面开始出现焦急状态， 无奈之下看答案了。两种hashmap的方法的空间复杂度为O(n),时间复杂度为O(n)。下面就将每个 解法的关键点列出来。 ¶暴力破解法 1234567891011121314public int[] twoSum(int[] nums, int target) &#123; if (null == nums || nums.length &lt;= 1) &#123; return new int[] &#123;-1, -1&#125;; &#125; int len = nums.length; for (int i = 0; i &lt; len; i++) &#123; for (int j = i + 1; j &lt; len; j++) &#123; if (nums[j] == target - nums[i]) &#123; return new int[] &#123; i, j &#125;; &#125; &#125; &#125; return new int[] &#123;-1, -1&#125;;&#125; ¶双哈希法 1234567891011121314151617public int[] twoSum(int[] nums, int target) &#123; if (null == nums || nums.length &lt;= 1) &#123; return new int[] &#123;-1, -1&#125;; &#125; Map&lt;Integer, Integer&gt; map = new HashMap&lt;Integer,Integer&gt;(); int len = nums.length; for (int i = 0; i &lt; len; i++) &#123; map.put(nums[i], i); &#125; for (int i = 0; i &lt; len; i++) &#123; int right = target - nums[i]; if (map.containsKey(right) &amp;&amp; map.get(right) != i) &#123; return new int[] &#123; i, map.get(right) &#125;; &#125; &#125; return new int[] &#123;-1, -1&#125;;&#125; ¶单哈希法 1234567891011121314public int[] twoSum(int[] nums, int target) &#123; if (null == nums || nums.length &lt;= 1) &#123; return new int[] &#123;-1, -1&#125;; &#125; Map&lt;Integer, Integer&gt; map = new HashMap&lt;Integer,Integer&gt;(); for (int i = 0; i &lt; len; i++) &#123; int right = target - nums[i]; if (map.containsKey(right)) &#123; return new int[] &#123; i, map.get(right) &#125;; &#125; map.put(right, i); &#125; return new int[] &#123;-1, -1&#125;;&#125; ¶总结 以后做算法题或者解决难题的时候，要懂得放一放，不要非得在一定的时间之内完成，特别是在做算法题。 毕竟在leetcode上做算法题不是为了刷题目，而是为了锻炼自己的思维还有夯实算法知识。","comments":true,"tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://yoursite.com/tags/algorithm/"}]},{"title":"测试驱动开发笔记之入门","date":"2018-06-22T16:00:00.000Z","path":"2018/06/23/arts/share/S-TDD-note/","text":"¶无意间接触TDD 以前写个小函数之后，一直用main函数来做单元测试。看看是否有其他的方法，不用老这么整。 后面听到过xUnit啥，然后在网上也看一部分资料，Junit简要入门,junit-tutorials等。 弄完之后觉得好奇，想知道Junit是谁先提出的，无意间就找到 Kent Beck 的一本关于测试驱动开发的书： 《Test-Driven Development By Example》。 ¶TDD 小结 后面每天抽点时间把第一章的知识看完，主要围绕资金实例一步一步的介绍测试驱动开发，作者忒细心， 深怕介绍的过快而没有讲清楚。今日把相关的要点列出来，最近慢慢在开始练习开发模式写代码。示例代码 可以参考TDD。 ¶测试驱动开发的目标 每一种开发方法都是为了解决某个问题而来的，而测试驱动开发的目的就是为让人写出整洁可用的代码。 ¶测试驱动开发的态度 测试优先 只有自动测试失败时，才重写代码 不可运行/可运行/重构 不断构建测试列表 ¶测试驱动开发的过程 加入一个小的测试； 运行所有测试，运行测试； 适当修改; 运行测试且成功; 重构，消除重复设计，优化设计结构。 ¶三个测试驱动开发小技巧 让测试利落运行的三种方法 伪方法:返回一个常量并逐渐用变量代替常量，直至伪实现代码成为真实地代码 三角法：在例子达到2个或更多时才对代码实施一般化 显明实现：实现真实的代码 把消除代码与测试间的重复设计作为驱动设计的一种手段 控制测试间隙的能力，不知如何下手，就放慢，在状况好时就开快一些 ¶参考资料 http://www.vogella.com/tutorials/JUnit/article.html http://www.mkyong.com/tutorials/junit-tutorials/","comments":true,"tags":[{"name":"TDD","slug":"TDD","permalink":"http://yoursite.com/tags/TDD/"},{"name":"share","slug":"share","permalink":"http://yoursite.com/tags/share/"}]},{"title":"一个bug引发另个bug","date":"2018-06-22T16:00:00.000Z","path":"2018/06/23/arts/tip/T-onlineproblem/","text":"¶一个bug背景 在周三快下班的时候，临时接到需求，需要修改协议书模板，后端只需要修改脚本即可。由于周四是版本 上线的最后一天，所以建议不要修改，原因如下： 每次发版当天的环境会很差，各个关联方环境极其不稳定； 本身有很多需求都没全部覆盖测试； 改完之后都需要走回归测试，测试同事有时间么； 但是组长觉得小小需求，测试负责人也说支持。最后妥协，修改了，当天就搞定了。周四开始回归测试，测试 同事测试出一个bug了，为说明此bug产生的缘由，说明一些简称： 1.客户级别L：（0：低；1：高）; 2.数据源： 客户OCR扫描完证件信息（A） 本地数据库（B） 客户预留信息（C） 关系方的信息（D） 3.渠道：A 和 B 需求做一个比对，判断是否同一个人，此需求是小灰同事负责开发（同事之间需要和谐相处说，随意取名小 灰。 ），在此将简单写成伪代码，如下： 12345678910111213141516171819202122232425262728293031 res = false // 块1 if A then if A == B then res = true else res = false END END// 块2 if L == 0 then // 块2.1 if D 存在 then if A == D then res = true else res = false END else res = true END // 块2.2 else if A == C then res = true else res = false END END return res 周四测试同事发现低级别的客户，OCR扫的与本地库不同，居然也认为是本人，所以将bug给小灰和我。当 时我看着日志，把数据对比的数据拿出来，写单元测试，发现确实如此。然后就叫小灰过来，给他讲了一下， 发现的问题，A渠道来的在块1比较是不同的人，客户又是低级的而D数据不存，覆盖了之前校验的值，将其 变为是本人了。后面他说：“不是很明白，回桌上自己想想”。最后他说改完了，移交测试了。由于我负责其 他的需求开发，负责查日志，忙着就忘记去看小灰怎么改的。后面就上线了，由于小灰需要支持版本发布， 周五调休。 ¶另一个bug背景 周五一上班，大概10点多，收到很多邮件，一会查这个一会查另外一个。当天看到6笔报不是本人的异常， 赶紧查日志。拉取最新的代码，查完分析代码。小灰修改后的代码，改写伪代码如下： 1234567891011121314151617181920212223242526272829303132res = false // 块1 if A then if A == B then res = true else res = false END END// 块2 if L == 0 then // 块2.1 if D 存在 then if A == D then res = true else res = false END //else // 小灰修改处 // res = true END // 块2.2 else if A == C then res = true else res = false END END return res 分析出来是，B渠道，低级别客户，在数据D不存在的情况下，一直是非本人。所以与测试沟通造相关的数 据，复现生成问题。 ¶bug修复处理 最后跟领导申请紧急版本处理修复，由于是由一个bug引起bug，问了如下三个问题： 修改的代码是否有review 测试同事是否有案例review 是否负责人报备 我的回答都是否定的，当时发现第一个bug的时候，我跟测试负责人打了招呼，但是没有跟组长说，后面也没 有review小灰修改的代码。处理此事我司步骤如下： 发邮件申请紧急版本给部门长； 开发直属领导与部门长说明bug问题； 修复bug 测试回归 发布版本 生成验证 修改小灰的代码如下： 12345678910111213141516171819202122232425262728293031res = false // 块1 if A then if A == B then res = true else return false // 修1 END END// 块2 if L == 0 then // 块2.1 if D 存在 then if A == D then res = true else return false // 修改2 END else // 修改3 仍旧加上 res = true END // 块2.2 else if A == C then res = true else res = false END END return res 然后与组长一起review代码，影响业务比较大，所以需要快速解决，没有重构代码。好了之后，画好流程 图，给测试同事讲解，再告诉测试同事在测试环境造什么样的数据，让其一个分支一个分支的测试。上线之 后，自己又找人生产验证。 ¶总结 问责的时候，心里面确实不舒服，不是我的错，为啥要我承担。 后面想想，自己也有责任，发现了bug， 没有和小灰一同修复。今天就把此两个bug回顾，总结如下： 复杂的业务逻辑画好流程图，与测试同事一同案例评审； 开发单元测试一定做足； 不要逃避责任。","comments":true,"tags":[{"name":"bug","slug":"bug","permalink":"http://yoursite.com/tags/bug/"},{"name":"线上问题","slug":"线上问题","permalink":"http://yoursite.com/tags/线上问题/"}]},{"title":"mock和RAP入门教程","date":"2017-07-30T16:00:00.000Z","path":"2017/07/31/mock-rap-basic-uasge/","text":"在很早以前公司里面就接入了rap在线管理接口文档平台，通过图形化书写接口文档，给前端同事使用。但是之前也仅仅是用于写接口文档，从来没有研究过它还有其他用途。最近与自己合作的一个前端同事说，你为啥不利用好rap来写接口文档，它会自动生成mock数据，我们就不用将rap默认生成的数据修改后，再本地测试一下。弄完之后再与你们联调。今儿就花了2个小时左右研究一下rap，顺藤摸瓜出来mock。下面简单介绍一下，mock以及如何在rap中使用mock，生成比较好的模拟数据，提高前后端协作效率。 ¶mock.js1 mock.js随机生成数据，让前端开发人员在开发阶段时独立于后端，使用mockjs可以自测代码。 ¶语法规范 数据模板定义规范(DTD:Data Template Definition) 数据占位符规范(DPD: Data Placeholder definition) ¶数据模板定义规范 ¶格式 'name|rule':value (属性名|生成规则:属性值)，其中生成规则是可选的 ¶生成规则 7种生成规则 'name|min-max':value 'name|count':value 'name|min-max.dmin-dmax':value 'name|+step':value 'name|min-max.dcount':value 'name|count.dmin-dmax':value 'name|count.dcount':value 生成规则的含义依赖属性值的类型才能确认，这一点特别重要。也是mock的关键所在。 比如： 'name|min-max':string: 通过重复[min,max]次string生成新字符串。 'name|min-max':number: 生成一个number，返回在[min,max]。 ¶属性值 属性值可含@（占位符） 指定最终的值和类型 属性值类型 String Number Boolean Object Array Function RegExp Path 学过js看着十分简单，只是多了RegExp 和 Path，其他简直一模一样。 ¶数据占位符定义规范DPD ¶占位符 1.占位符只是在属性字符串中占个位置，并不出现在最终的属性值中 2.格式：@占位符或者@占位符(参数[,参数]) 3.占位符 用@标识后面的字符串是占位符 引用的是Mock.Random中的方法 扩展定义占位符：Mock.Random.extend() 引用数据模板中的属性 支持相对路径和绝对路径 4.数据占位符类型 数据占位符一共有如下几种类型： Basic Date Image Color Text Name Web Address Helper Miscellaneous 具体mock语法示例，请参考mock示例2，里面详细的介绍了各个类型使用方法。 ¶rap写接口文档中运用mock3 ¶什么是rap RAP是前后端沟通桥梁的通信接口，是一个图形化的接口文档管理的软件。它可以自动生成mock数据，在开发时候前端同事可以不依赖于后端的数据，而是根据mock规则自动生成的模拟数据进行测试。 ¶怎么在rap中是使用mock 有很多资料，且是图文并茂写博文4,5。总结起来，在rap中运用mock方法如下： 左边变量写 name|rule，此处相当于就是mock中的'name|rule'; 右边备注写 @mock=value。其语法规则mock一样。 1.https://github.com/nuysoft/Mock/wiki ↩2.http://mockjs.com/examples.html ↩3.https://github.com/thx/RAP/wiki/ ↩4.http://www.imooc.com/article/17588 ↩5.http://blog.sina.com.cn/s/blog_c00ccc680102x0ue.html ↩","comments":true,"tags":[{"name":"mock","slug":"mock","permalink":"http://yoursite.com/tags/mock/"},{"name":"RAP","slug":"RAP","permalink":"http://yoursite.com/tags/RAP/"}]},{"title":"python实现http发送POST请求","date":"2017-07-24T16:00:00.000Z","path":"2017/07/25/python-http-post/","text":"现在开发是前后端完全分离的，在公司里面很多接口都和登陆态相关联起来。从而使得我在需求开发的时候依赖于前端同事打包完之后才开始测试自己的需求功能。所以比较耗费时间和精力。但是我们的服务接口是不依赖登陆态的，为了测试自己的服务接口，需要模拟发送HTTP请求，以便后面偷懒。本文就此介绍一下如何解决此问题。 ¶语言选择以及依赖包 为了能够快速解决此问题，首先需要找到合适的工具，俗话说，“工欲善其事，必先利其器。” 在程序设计中首先就是语言的选择，相比于java，对python更为熟悉一点。说句皮外话， 虽然在公司用java开发，但是对java熟悉程度不如python,汗颜啦。回归正题，选好了 语言之后，紧接着就是如何模拟发送HTTP请求。google一番找到一个第三方包urllib3。 如何安装urllib3以及使用文档教程。 ¶实现 现在我们来看看，如何使用urllib3包来模拟发送HTTP的POST请求，请求参数是JSON格式。为了能够使用urllib3模块，需要在使用导入urllib3模块，代码：import urllib3。使用PoolManager 实例来发送请求，它已经为我们封装处理好了连接池以及线程安全问题，我们没有必要再次徒手开发一套。其实，urllib3中最为核心关键的方法是request方法，它指定发送请求的方式、请求地址请求的参数。具体步骤如下： 指定请求方法以及url; 将请求的参数编码，然后作为body的值; 设置请求头部的Content-Type为JSON格式. 下面是一个示例代码： 12345678910111213#-*- coding:utf-8 -*-import urllib3from urllib import urlencodeimport jsondef testEsaInterface(url, param): http = urllib3.PoolManager() try: r = http.request('POST',url, body=json.dumps(param).encode('utf-8'),headers=&#123;'Content-Type': 'application/json'&#125;) if r.status == 200: print r.data except urllib3.exceptions.MaxRetryError as e: print repr(e) 如果想对返回的结果进行处理，先将返回的数据进行解码以及反序列化，可以使用decode函数解码，loads函数反序列化。然后采用类似于下标的访问方式获取相关字段的值。示例代码如下： 123res = json.loads(r.data.decode('utf-8'))if (\"906\" == res['data']['returnCode']): # to do something 下图是我测试人脸识别功能一个测试结果： ¶postman发送post请求 弄完工具之后，本来想再做一个网页版的，后面发现chrome中有一个插件postman, 可以解决我的问题，突然发现重复造轮子咯。下面简单介绍一下，如何用postman发送 post请求，其中请求的参数为JSON格式。步骤如下： 选择发送请求的方式为 POST; 输入访问的URL 在headers标签页输入 Content-type, 对应的值为 application/json; 在body标签页面，选择raw,然后在输入JSON格式的请求参数; 最后点击send按钮即可. 是不是发现很简单，如果你觉得还是不清楚,可以参考此博文。 本文仅仅简单介绍了urllib3模块发送HTTP的POST请求方式，还有很多功能需要大家自己去发掘。 ¶参考 安装urllib3: https://pypi.python.org/pypi/urllib3/ urllib3的使用教程: https://urllib3.readthedocs.io/en/latest/user-guide.html postman以JSON格式发送POST请求: http://www.cnblogs.com/shimh/p/6093229.html","comments":true,"tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"},{"name":"http","slug":"http","permalink":"http://yoursite.com/tags/http/"}]},{"title":"sicp 数据对象之集合操作","date":"2017-07-21T16:00:00.000Z","path":"2017/07/22/sicp-dataobject-set/","text":"本文主要介绍不同的数据抽象，对应用程序在使用公共函数时会造成何种影响。这里主要是使用集合使用三种数据来表示：集合作为未排序的表、集合作为排序的表、集合作为有序二叉树，探讨不同的数据对象形式表示集合时，对使用集合的程序性能的影响。 ¶基本概念 选择函数与构造函数 构造函数：说明一个数据对象是由哪些原始组成的。 选择函数：怎么将数据对象中的组成元素抽取出来。 数据抽象定义 数据定义就是一组选择函数与构造函数，以及为了使它们成为一套合法的表示。因此它们需要满足一组特定的条件。 看着上面两个定义是不是很拗口，不知道在说啥。举个例子来说，如果一个有理数p是由整数 n 和 整数 d 构造而成。也就是 p = n /d。 12345;构造函数 p = n / dp = (make-rat n d);选择函数n = (numer p)d = (denom p) ¶集合操作 在高中的数学我们学习过，集合表示一组无重复的元素聚集而成。在数据结构中，集合表示一组具有相同属性的元素，并且满足数学中的集合属性：无序性。 常见集合的操作，判断某个元素是否属于某个集合、求两个集合的交集、求两个集合的并集。假设集合A={1,2,3}、B={2,3,4}，以及元素m=2,n=5，则： 判断某个元素是否属于某个集合：m 属于A,也属于B，而n不属于A,也不属于B; A 与 B 的交集为：{2, 3}; A 与 B 的并集为：{1, 2, 3, 4} 下面我们来看看使用三种不同的数据表示，会对写集合常见操作造成什么样影响。 ¶集合作为未排序的表 ¶构造函数与选择函数 直接使用list 函数，但是集合中元素是排序的，比如集合A={1, 10, 2, 4, 3}。 ¶判断某个元素是否属于某个集合 1234(define (element-of-set? x set) (cond ((null? set) #f) (else (or (equal? x (car set)) (element-of-set? x (cdr set)))))) ¶求两个集合的交集 12345(define (intersection-set set1 set2) (cond ((or (null? set1) (null? set2)) &apos;()) ((element-of-set? (car set1) set2) (cons (car set1) (intersection-set (cdr set1) set2))) (else (intersection-set (cdr set1) set2)))) ¶求两个集合的并集 123456(define (union-set set1 set2) (cond ((null? set1) set2) ((null? set2) set1) ((element-of-set? (car set1) set2) (union-set (cdr set1) set2)) (else (cons (car set1) (union-set (cdr set1) set2))))) ¶将某个元素加入集合中 1234(define (adjion-set x set) (if (element-of-set? x set) set (cons x set))) ¶集合作为排序的表 ¶构造函数与选择函数 直接使用list 函数，但是集合中元素是排序的，比如集合A={1, 2, 3, 4, 5, 10}。 ¶判断某个元素是否属于某个集合 12345(define (element-of-set? x set) (cond ((null? set) #f) ((equal? x (car set)) #t) ((&lt; x (car set)) #f) (else (element-of-set? x (cdr set))))) ¶求两个集合的交集 12345678(define (intersection-sort-set set1 set2) (if (or (null? set1) (null? set2)) &apos;() (let ((x (car set1)) (y (car set2))) (cond ((= x y) (cons x (ntersection-sort-set (cdr set1) (cdr set2)))) ((&lt; x y) (intersection-sort-set (cdr set1) set2)) (else (intersection-sort-set set1 (cdr set2))))))) ¶将某个元素加入到集合中 12345(define (adjoin-set x set) (cond ((null? set) (cons x set)) ((equal? x (car set)) set) ((&lt; x (car set)) (cons x set)) (else (cons (car set) (adjoin-set x (cdr set)))))) ¶求两个集合的并集 12345678(define (union-sort-set set1 set2) (cond ((null? set1) set2) ((null? set2) set1) (else (let ((x (car set1)) (y (car set2))) (cond ((&lt; x y) (cons x (nion-sort-set (cdr set1) set2))) ((&gt; x y) (cons y (union-sort-set set1 (cdr set2)))) (else (cons x (union-sort-set(cdr set1) (cdr set2))))))))) ¶集合作为有序二叉树 ¶构造函数与选择函数 1234567891011;(dataItem, left-branch, right-branch)(define (entry tree) (car tree))(define (left-branch tree) (cadr tree))(define (right-branch tree) (caddr tree))(define (make-tree entry left-branch right-branch) (list entry left-branch right-branch)) ¶判断某个元素是否属于某个集合 1234567(define (element-of-set? x set) (if (null? set) #f (let ((dataItem (entry set))) (cond ((= dataItem x) #t) ((&gt; dataItem x) (element-of-set x (left-branch set))) (else (element-of-set x (right-branch set))))))) ¶求两个集合的交集 12345(define (intersection-set set1 set2) (let ((list1 (tree-&gt;list set1)) (list2 (tree-&gt;list set2))) (let ((res (intersection-sort-set list1 list2))) (list-tree res)))) ¶求两个集合的并集 1234567891011121314151617181920212223242526272829303132333435; 辅助函数：将树形结构转为列表结构(define (tree-&gt;list tree) (define (copy-to-list tree result-list) (if (null? tree) result-list (copy-to-list (left-branch tree) (cons (entry tree) (copy-to-list (right-branch tree) result-list))))) (copy-to-list tree &apos;()));辅助函数：将列表结构转位树形结构(define (list-tree elements) (car (partial-tree elements (length elements))))(define (partial-tree elts n) (if (= n 0) (cons &apos;() elts) (let ((left-size (quotient (- n 1) 2))) (let ((left-result (partial-tree elts left-size))) (let ((left-tree (car left-result)) (non-left-elts (cdr left-result)) (right-size (- n (+ left-size 1)))) (let ((this-entry (car non-left-elts)) (right-result (partial-tree (cdr non-left-elts) right-size))) (let ((right-tree (car right-result)) (remaining-elts (cdr right-result))) (cons (make-tree this-entry left-tree right-tree) remaining-elts))))))))(define (union-set set1 set2) (let ((list1 (tree-&gt;list set1)) (list2 (tree-&gt;list set2))) (let ((res (union-sort-set list1 list2))) (list-tree res)))) ¶添加元素到集合 123456789(define (adjoin-set x set) (cond ((null? set) (make-tree x &apos;() &apos;())) ((= x (entry set)) set) ((&lt; x (entry set)) (make-tree (entry set) (adjoin-set x (left-branch set)) (right-branch set))) (else (make-tree (entry set) (left-branch set) (adjoin-set x (right-branch set)))))) ¶总结 通过三种不同的数据表示集合，分析了程序在使用集合操作，比如检查是否属于集合、集合的交集、集合并集等操作，在时间复杂度上是存在差异的。如下表格： 表示法 检查元素是否属于集合 添加元素 交集 并集 未排序的表 O(n) O(n) O(n^2) O(n^2) 排序的表 O(n) O(n) O(n) O(n) 有序二叉树 O(log n) O(log n) O(n) O(n) 也就是我们常说: 程序=数据结构+算法","comments":true,"tags":[{"name":"sicp","slug":"sicp","permalink":"http://yoursite.com/tags/sicp/"},{"name":"scheme","slug":"scheme","permalink":"http://yoursite.com/tags/scheme/"}]},{"title":"Hello World","date":"2017-07-21T16:00:00.000Z","path":"2017/07/22/hello-world/","text":"大家好： 本文是使用Hexo的第一篇博文，主要是给大家报个到。欢迎来到我的菜园子。","comments":true,"tags":[{"name":"随记","slug":"随记","permalink":"http://yoursite.com/tags/随记/"}]}]